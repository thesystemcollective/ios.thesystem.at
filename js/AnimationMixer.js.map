{"version":3,"file":"AnimationMixer.js","sources":["../../node_modules/three/src/animation/AnimationAction.js","../../node_modules/three/src/animation/PropertyMixer.js","../../node_modules/three/src/animation/AnimationMixer.js"],"sourcesContent":["import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat, NormalAnimationBlendMode, AdditiveAnimationBlendMode } from '../constants.js';\n\nfunction AnimationAction( mixer, clip, localRoot, blendMode ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\tthis.blendMode = blendMode || clip.blendMode;\n\n\tconst tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tconst interpolantSettings = {\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\t};\n\n\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants; // bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null; // for the memory manager\n\tthis._byClipCacheIndex = null; // for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = LoopRepeat;\n\tthis._loopCount = - 1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\tthis.paused = false; // true -> zero effective time scale\n\tthis.enabled = true; // false -> zero effective weight\n\n\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n}\n\nObject.assign( AnimationAction.prototype, {\n\n\t// State & Scheduling\n\n\tplay: function () {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function () {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function () {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function () {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function ( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function ( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function ( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function () {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function () {\n\n\t\tlet weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function ( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function () {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function ( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function ( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function ( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function () {\n\n\t\tlet timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function () {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function () {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function () {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function ( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function ( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function ( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { AnimationAction };\n","import { Quaternion } from '../math/Quaternion.js';\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tlet mixFunction,\n\t\tmixFunctionAdditive,\n\t\tsetIdentity;\n\n\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\t//\n\t// 'add' is used for additive cumulative results\n\t//\n\t// 'work' is optional and is only present for quaternion types. It is used\n\t// to store intermediate quaternion multiplication results\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\tthis._workIndex = 5;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tmixFunction = this._select;\n\n\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t// additive is not relevant for non-numeric types\n\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t}\n\n\tthis._mixBufferRegion = mixFunction;\n\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\tthis._setIdentity = setIdentity;\n\tthis._origIndex = 3;\n\tthis._addIndex = 4;\n\n\tthis.cumulativeWeight = 0;\n\tthis.cumulativeWeightAdditive = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive: function ( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\t_setAdditiveIdentityNumeric: function () {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t},\n\n\t_setAdditiveIdentityQuaternion: function () {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * 4 + 3 ] = 1;\n\n\t},\n\n\t_setAdditiveIdentityOther: function () {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t},\n\n\t_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { PropertyMixer };\n","import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tlet actionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime: function ( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationMixer };\n"],"names":["AnimationAction","mixer","clip","localRoot","blendMode","this","_mixer","_clip","_localRoot","tracks","nTracks","length","interpolants","Array","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","i","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","Infinity","paused","enabled","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","PropertyMixer","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","Object","assign","prototype","play","_activateAction","stop","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","now","_lendControlInterpolant","times","parameterPositions","values","sampleValues","timeScaleInterpolant","getMixer","getClip","getRoot","_update","deltaTime","timeDirection","accuIndex","_updateWeight","startTime","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","AdditiveAnimationBlendMode","j","m","evaluate","accumulateAdditive","NormalAnimationBlendMode","accumulate","interpolantValue","loopCount","pingPong","LoopPingPong","LoopOnce","_setEndings","handle_stop","dispatchEvent","type","direction","loopDelta","Math","floor","abs","pending","atStart","atEnd","ZeroSlopeEnding","WrapAroundEnding","weightNow","weightThen","stride","offset","currentWeight","mix","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","Quaternion","slerpFlat","workOffset","multiplyQuaternionsFlat","s","create","EventDispatcher","constructor","_bindAction","prototypeAction","bindings","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","track","trackName","name","_addInactiveBinding","path","parsedPath","PropertyBinding","ValueTypeName","getValueSize","resultBuffer","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","keys","firstInactiveBinding","lastActiveBinding","LinearInterpolant","Float32Array","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","AnimationClip","findByName","existingAction","newAction","stopAllAction","update","nActions","sign","nBindings","setTime","timeInSeconds","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"mappings":"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"}