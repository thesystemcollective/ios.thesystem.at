{"version":3,"file":"Triangle.js","sources":["../../node_modules/three/src/math/Ray.js","../../node_modules/three/src/math/Plane.js","../../node_modules/three/src/math/Triangle.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nconst _vector = new Vector3();\nconst _segCenter = new Vector3();\nconst _segDir = new Vector3();\nconst _diff = new Vector3();\n\nconst _edge1 = new Vector3();\nconst _edge2 = new Vector3();\nconst _normal = new Vector3();\n\nfunction Ray( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );\n\n}\n\nObject.assign( Ray.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function ( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t},\n\n\tclosestPointToPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function ( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t},\n\n\tdistanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t},\n\n\tintersectSphere: function ( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t},\n\n\tintersectPlane: function ( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t},\n\n\tintersectTriangle: function ( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t},\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n} );\n\n\nexport { Ray };\n","import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = new Vector3();\nconst _vector2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\nfunction Plane( normal, constant ) {\n\n\t// normal is assumed to be normalized\n\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n}\n\nObject.assign( Plane.prototype, {\n\n\tisPlane: true,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function ( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t},\n\n\tintersectLine: function ( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t},\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n} );\n\n\nexport { Plane };\n","import { Vector3 } from './Vector3.js';\nimport { Plane } from './Plane.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _v3 = new Vector3();\n\nconst _vab = new Vector3();\nconst _vac = new Vector3();\nconst _vbc = new Vector3();\nconst _vap = new Vector3();\nconst _vbp = new Vector3();\nconst _vcp = new Vector3();\n\nfunction Triangle( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n}\n\nObject.assign( Triangle, {\n\n\tgetNormal: function ( a, b, c, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0.subVectors( a, b );\n\t\ttarget.cross( _v0 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t},\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tgetBarycoord: function ( point, a, b, c, target ) {\n\n\t\t_v0.subVectors( c, a );\n\t\t_v1.subVectors( b, a );\n\t\t_v2.subVectors( point, a );\n\n\t\tconst dot00 = _v0.dot( _v0 );\n\t\tconst dot01 = _v0.dot( _v1 );\n\t\tconst dot02 = _v0.dot( _v2 );\n\t\tconst dot11 = _v1.dot( _v1 );\n\t\tconst dot12 = _v1.dot( _v2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t},\n\n\tcontainsPoint: function ( point, a, b, c ) {\n\n\t\tTriangle.getBarycoord( point, a, b, c, _v3 );\n\n\t\treturn ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );\n\n\t},\n\n\tgetUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3 );\n\n\t\ttarget.set( 0, 0 );\n\t\ttarget.addScaledVector( uv1, _v3.x );\n\t\ttarget.addScaledVector( uv2, _v3.y );\n\t\ttarget.addScaledVector( uv3, _v3.z );\n\n\t\treturn target;\n\n\t},\n\n\tisFrontFacing: function ( a, b, c, direction ) {\n\n\t\t_v0.subVectors( c, b );\n\t\t_v1.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tgetArea: function () {\n\n\t\t_v0.subVectors( this.c, this.b );\n\t\t_v1.subVectors( this.a, this.b );\n\n\t\treturn _v0.cross( _v1 ).length() * 0.5;\n\n\t},\n\n\tgetMidpoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tgetNormal: function ( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t},\n\n\tgetPlane: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Plane();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tgetBarycoord: function ( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t},\n\n\tgetUV: function ( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tisFrontFacing: function ( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t},\n\n\tclosestPointToPoint: function ( p, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t},\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n} );\n\n\nexport { Triangle };\n"],"names":["_vector","Vector3","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","origin","direction","this","undefined","Object","assign","prototype","set","copy","clone","constructor","ray","at","t","target","multiplyScalar","add","lookAt","v","sub","normalize","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","intersectsBox","intersectTriangle","a","b","backfaceCulling","crossVectors","sign","DdN","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","transformDirection","equals","_vector1","_vector2","_normalMatrix","Matrix3","Plane","isPlane","setComponents","w","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","length","negate","distanceToSphere","projectPoint","intersectLine","line","delta","start","intersectsLine","startSign","endSign","end","coplanarPoint","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","_v0","_v1","_v2","_v3","_vab","_vac","_vbc","_vap","_vbp","_vcp","Triangle","getNormal","targetLengthSq","getBarycoord","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","containsPoint","getUV","p1","p2","p3","uv1","uv2","uv3","addScaledVector","isFrontFacing","setFromPointsAndIndices","points","i0","i1","i2","triangle","getArea","getMidpoint","addVectors","getPlane","intersectsTriangle","p","d1","d3","d4","vc","d5","d6","vb","va"],"mappings":"yCAEA,MAAMA,EAAU,IAAIC,EACdC,EAAa,IAAID,EACjBE,EAAU,IAAIF,EACdG,EAAQ,IAAIH,EAEZI,EAAS,IAAIJ,EACbK,EAAS,IAAIL,EACbM,EAAU,IAAIN,EAEpB,SAASO,EAAKC,EAAQC,GAErBC,KAAKF,YAAsBG,IAAXH,EAAyBA,EAAS,IAAIR,EACtDU,KAAKD,eAA4BE,IAAdF,EAA4BA,EAAY,IAAIT,EAAS,EAAG,GAAK,GAIjFY,OAAOC,OAAQN,EAAIO,UAAW,CAE7BC,IAAK,SAAWP,EAAQC,GAKvB,OAHAC,KAAKF,OAAOQ,KAAMR,GAClBE,KAAKD,UAAUO,KAAMP,GAEdC,MAIRO,MAAO,WAEN,OAAO,IAAIP,KAAKQ,aAAcF,KAAMN,OAIrCM,KAAM,SAAWG,GAKhB,OAHAT,KAAKF,OAAOQ,KAAMG,EAAIX,QACtBE,KAAKD,UAAUO,KAAMG,EAAIV,WAElBC,MAIRU,GAAI,SAAWC,EAAGC,GASjB,YAPgBX,IAAXW,IAGJA,EAAS,IAAItB,GAIPsB,EAAON,KAAMN,KAAKD,WAAYc,eAAgBF,GAAIG,IAAKd,KAAKF,SAIpEiB,OAAQ,SAAWC,GAIlB,OAFAhB,KAAKD,UAAUO,KAAMU,GAAIC,IAAKjB,KAAKF,QAASoB,YAErClB,MAIRmB,OAAQ,SAAWR,GAIlB,OAFAX,KAAKF,OAAOQ,KAAMN,KAAKU,GAAIC,EAAGtB,IAEvBW,MAIRoB,oBAAqB,SAAWC,EAAOT,QAEtBX,IAAXW,IAGJA,EAAS,IAAItB,GAIdsB,EAAOU,WAAYD,EAAOrB,KAAKF,QAE/B,MAAMyB,EAAoBX,EAAOY,IAAKxB,KAAKD,WAE3C,OAAKwB,EAAoB,EAEjBX,EAAON,KAAMN,KAAKF,QAInBc,EAAON,KAAMN,KAAKD,WAAYc,eAAgBU,GAAoBT,IAAKd,KAAKF,SAIpF2B,gBAAiB,SAAWJ,GAE3B,OAAOK,KAAKC,KAAM3B,KAAK4B,kBAAmBP,KAI3CO,kBAAmB,SAAWP,GAE7B,MAAME,EAAoBlC,EAAQiC,WAAYD,EAAOrB,KAAKF,QAAS0B,IAAKxB,KAAKD,WAI7E,OAAKwB,EAAoB,EAEjBvB,KAAKF,OAAO+B,kBAAmBR,IAIvChC,EAAQiB,KAAMN,KAAKD,WAAYc,eAAgBU,GAAoBT,IAAKd,KAAKF,QAEtET,EAAQwC,kBAAmBR,KAInCS,oBAAqB,SAAWC,EAAIC,EAAIC,EAAoBC,GAS3D3C,EAAWe,KAAMyB,GAAKjB,IAAKkB,GAAKnB,eAAgB,IAChDrB,EAAQc,KAAM0B,GAAKf,IAAKc,GAAKb,YAC7BzB,EAAMa,KAAMN,KAAKF,QAASmB,IAAK1B,GAE/B,MAAM4C,EAAkC,GAAtBJ,EAAGK,WAAYJ,GAC3BK,GAAQrC,KAAKD,UAAUyB,IAAKhC,GAC5B8C,EAAK7C,EAAM+B,IAAKxB,KAAKD,WACrBwC,GAAO9C,EAAM+B,IAAKhC,GAClBgD,EAAI/C,EAAMgD,WACVC,EAAMhB,KAAKiB,IAAK,EAAIN,EAAMA,GAChC,IAAIO,EAAIC,EAAIC,EAASC,EAErB,GAAKL,EAAM,EAQV,GAJAE,EAAKP,EAAME,EAAKD,EAChBO,EAAKR,EAAMC,EAAKC,EAChBQ,EAASZ,EAAYO,EAEhBE,GAAM,EAEV,GAAKC,IAAQE,EAEZ,GAAKF,GAAME,EAAS,CAKnB,MAAMC,EAAS,EAAIN,EACnBE,GAAMI,EACNH,GAAMG,EACNF,EAAUF,GAAOA,EAAKP,EAAMQ,EAAK,EAAIP,GAAOO,GAAOR,EAAMO,EAAKC,EAAK,EAAIN,GAAOC,OAM9EK,EAAKV,EACLS,EAAKlB,KAAKuB,IAAK,IAAOZ,EAAMQ,EAAKP,IACjCQ,GAAYF,EAAKA,EAAKC,GAAOA,EAAK,EAAIN,GAAOC,OAQ9CK,GAAOV,EACPS,EAAKlB,KAAKuB,IAAK,IAAOZ,EAAMQ,EAAKP,IACjCQ,GAAYF,EAAKA,EAAKC,GAAOA,EAAK,EAAIN,GAAOC,OAMzCK,IAAQE,GAIZH,EAAKlB,KAAKuB,IAAK,KAASZ,EAAMF,EAAYG,IAC1CO,EAAOD,EAAK,GAAQT,EAAYT,KAAKwB,IAAKxB,KAAKuB,KAAOd,GAAaI,GAAMJ,GACzEW,GAAYF,EAAKA,EAAKC,GAAOA,EAAK,EAAIN,GAAOC,GAElCK,GAAME,GAIjBH,EAAK,EACLC,EAAKnB,KAAKwB,IAAKxB,KAAKuB,KAAOd,GAAaI,GAAMJ,GAC9CW,EAAUD,GAAOA,EAAK,EAAIN,GAAOC,IAMjCI,EAAKlB,KAAKuB,IAAK,IAAOZ,EAAMF,EAAYG,IACxCO,EAAOD,EAAK,EAAMT,EAAYT,KAAKwB,IAAKxB,KAAKuB,KAAOd,GAAaI,GAAMJ,GACvEW,GAAYF,EAAKA,EAAKC,GAAOA,EAAK,EAAIN,GAAOC,QAU/CK,EAAOR,EAAM,GAAQF,EAAYA,EACjCS,EAAKlB,KAAKuB,IAAK,IAAOZ,EAAMQ,EAAKP,IACjCQ,GAAYF,EAAKA,EAAKC,GAAOA,EAAK,EAAIN,GAAOC,EAgB9C,OAZKP,GAEJA,EAAmB3B,KAAMN,KAAKD,WAAYc,eAAgB+B,GAAK9B,IAAKd,KAAKF,QAIrEoC,GAEJA,EAAuB5B,KAAMd,GAAUqB,eAAgBgC,GAAK/B,IAAKvB,GAI3DuD,GAIRK,gBAAiB,SAAWC,EAAQxC,GAEnCvB,EAAQiC,WAAY8B,EAAOC,OAAQrD,KAAKF,QACxC,MAAMwD,EAAMjE,EAAQmC,IAAKxB,KAAKD,WACxBwD,EAAKlE,EAAQmC,IAAKnC,GAAYiE,EAAMA,EACpCE,EAAUJ,EAAOK,OAASL,EAAOK,OAEvC,GAAKF,EAAKC,EAAU,OAAO,KAE3B,MAAME,EAAMhC,KAAKC,KAAM6B,EAAUD,GAG3BI,EAAKL,EAAMI,EAGXE,EAAKN,EAAMI,EAGjB,OAAKC,EAAK,GAAKC,EAAK,EAAW,KAK1BD,EAAK,EAAW3D,KAAKU,GAAIkD,EAAIhD,GAG3BZ,KAAKU,GAAIiD,EAAI/C,IAIrBiD,iBAAkB,SAAWT,GAE5B,OAAOpD,KAAK4B,kBAAmBwB,EAAOC,SAAcD,EAAOK,OAASL,EAAOK,QAI5EK,gBAAiB,SAAWC,GAE3B,MAAMC,EAAcD,EAAME,OAAOzC,IAAKxB,KAAKD,WAE3C,GAAqB,IAAhBiE,EAGJ,OAA8C,IAAzCD,EAAMtC,gBAAiBzB,KAAKF,QAEzB,EAMD,KAIR,MAAMa,IAAQX,KAAKF,OAAO0B,IAAKuC,EAAME,QAAWF,EAAMG,UAAaF,EAInE,OAAOrD,GAAK,EAAIA,EAAI,MAIrBwD,eAAgB,SAAWJ,EAAOnD,GAEjC,MAAMD,EAAIX,KAAK8D,gBAAiBC,GAEhC,OAAW,OAANpD,EAEG,KAIDX,KAAKU,GAAIC,EAAGC,IAIpBwD,gBAAiB,SAAWL,GAI3B,MAAMM,EAAcN,EAAMtC,gBAAiBzB,KAAKF,QAEhD,GAAqB,IAAhBuE,EAEJ,OAAO,EAMR,OAFoBN,EAAME,OAAOzC,IAAKxB,KAAKD,WAExBsE,EAAc,GAYlCC,aAAc,SAAWC,EAAK3D,GAE7B,IAAI4D,EAAMC,EAAMC,EAAOC,EAAOC,EAAOC,EAErC,MAAMC,EAAU,EAAI9E,KAAKD,UAAUgF,EAClCC,EAAU,EAAIhF,KAAKD,UAAUkF,EAC7BC,EAAU,EAAIlF,KAAKD,UAAUoF,EAExBrF,EAASE,KAAKF,OA0BpB,OAxBKgF,GAAW,GAEfN,GAASD,EAAIrB,IAAI6B,EAAIjF,EAAOiF,GAAMD,EAClCL,GAASF,EAAItB,IAAI8B,EAAIjF,EAAOiF,GAAMD,IAIlCN,GAASD,EAAItB,IAAI8B,EAAIjF,EAAOiF,GAAMD,EAClCL,GAASF,EAAIrB,IAAI6B,EAAIjF,EAAOiF,GAAMD,GAI9BE,GAAW,GAEfN,GAAUH,EAAIrB,IAAI+B,EAAInF,EAAOmF,GAAMD,EACnCL,GAAUJ,EAAItB,IAAIgC,EAAInF,EAAOmF,GAAMD,IAInCN,GAAUH,EAAItB,IAAIgC,EAAInF,EAAOmF,GAAMD,EACnCL,GAAUJ,EAAIrB,IAAI+B,EAAInF,EAAOmF,GAAMD,GAI7BR,EAAOG,GAAaD,EAAQD,EAAgB,OAK9CC,EAAQF,GAAQA,GAASA,KAAOA,EAAOE,IAEvCC,EAAQF,GAAQA,GAASA,KAAOA,EAAOE,GAEvCO,GAAW,GAEfN,GAAUL,EAAIrB,IAAIiC,EAAIrF,EAAOqF,GAAMD,EACnCL,GAAUN,EAAItB,IAAIkC,EAAIrF,EAAOqF,GAAMD,IAInCN,GAAUL,EAAItB,IAAIkC,EAAIrF,EAAOqF,GAAMD,EACnCL,GAAUN,EAAIrB,IAAIiC,EAAIrF,EAAOqF,GAAMD,GAI7BV,EAAOK,GAAaD,EAAQH,EAAgB,OAE9CG,EAAQJ,GAAQA,GAASA,KAAOA,EAAOI,IAEvCC,EAAQJ,GAAQA,GAASA,KAAOA,EAAOI,GAIvCJ,EAAO,EAAW,KAEhBzE,KAAKU,GAAI8D,GAAQ,EAAIA,EAAOC,EAAM7D,MAI1CwE,cAAe,SAAWb,GAEzB,OAA6C,OAAtCvE,KAAKsE,aAAcC,EAAKlF,IAIhCgG,kBAAmB,SAAWC,EAAGC,EAAG/C,EAAGgD,EAAiB5E,GAMvDlB,EAAO4B,WAAYiE,EAAGD,GACtB3F,EAAO2B,WAAYkB,EAAG8C,GACtB1F,EAAQ6F,aAAc/F,EAAQC,GAO9B,IACI+F,EADAC,EAAM3F,KAAKD,UAAUyB,IAAK5B,GAG9B,GAAK+F,EAAM,EAAI,CAEd,GAAKH,EAAkB,OAAO,KAC9BE,EAAO,MAED,CAAA,KAAKC,EAAM,GAOjB,OAAO,KALPD,GAAS,EACTC,GAAQA,EAQTlG,EAAM6B,WAAYtB,KAAKF,OAAQwF,GAC/B,MAAMM,EAASF,EAAO1F,KAAKD,UAAUyB,IAAK7B,EAAO8F,aAAchG,EAAOE,IAGtE,GAAKiG,EAAS,EAEb,OAAO,KAIR,MAAMC,EAASH,EAAO1F,KAAKD,UAAUyB,IAAK9B,EAAOoG,MAAOrG,IAGxD,GAAKoG,EAAS,EAEb,OAAO,KAKR,GAAKD,EAASC,EAASF,EAEtB,OAAO,KAKR,MAAMI,GAAQL,EAAOjG,EAAM+B,IAAK5B,GAGhC,OAAKmG,EAAM,EAEH,KAKD/F,KAAKU,GAAIqF,EAAMJ,EAAK/E,IAI5BoF,aAAc,SAAWC,GAKxB,OAHAjG,KAAKF,OAAOkG,aAAcC,GAC1BjG,KAAKD,UAAUmG,mBAAoBD,GAE5BjG,MAIRmG,OAAQ,SAAW1F,GAElB,OAAOA,EAAIX,OAAOqG,OAAQnG,KAAKF,SAAYW,EAAIV,UAAUoG,OAAQnG,KAAKD,cCpfxE,MAAMqG,EAAW,IAAI9G,EACf+G,EAAW,IAAI/G,EACfgH,EAAgB,IAAIC,EAE1B,SAASC,EAAOvC,EAAQC,GAIvBlE,KAAKiE,YAAsBhE,IAAXgE,EAAyBA,EAAS,IAAI3E,EAAS,EAAG,EAAG,GACrEU,KAAKkE,cAA0BjE,IAAbiE,EAA2BA,EAAW,EAIzDhE,OAAOC,OAAQqG,EAAMpG,UAAW,CAE/BqG,SAAS,EAETpG,IAAK,SAAW4D,EAAQC,GAKvB,OAHAlE,KAAKiE,OAAO3D,KAAM2D,GAClBjE,KAAKkE,SAAWA,EAETlE,MAIR0G,cAAe,SAAW3B,EAAGE,EAAGE,EAAGwB,GAKlC,OAHA3G,KAAKiE,OAAO5D,IAAK0E,EAAGE,EAAGE,GACvBnF,KAAKkE,SAAWyC,EAET3G,MAIR4G,8BAA+B,SAAW3C,EAAQ5C,GAKjD,OAHArB,KAAKiE,OAAO3D,KAAM2D,GAClBjE,KAAKkE,UAAa7C,EAAMG,IAAKxB,KAAKiE,QAE3BjE,MAIR6G,sBAAuB,SAAWvB,EAAGC,EAAG/C,GAEvC,MAAMyB,EAASmC,EAAS9E,WAAYkB,EAAG+C,GAAIO,MAAOO,EAAS/E,WAAYgE,EAAGC,IAAMrE,YAMhF,OAFAlB,KAAK4G,8BAA+B3C,EAAQqB,GAErCtF,MAIRO,MAAO,WAEN,OAAO,IAAIP,KAAKQ,aAAcF,KAAMN,OAIrCM,KAAM,SAAWyD,GAKhB,OAHA/D,KAAKiE,OAAO3D,KAAMyD,EAAME,QACxBjE,KAAKkE,SAAWH,EAAMG,SAEflE,MAIRkB,UAAW,WAIV,MAAM4F,EAAsB,EAAM9G,KAAKiE,OAAO8C,SAI9C,OAHA/G,KAAKiE,OAAOpD,eAAgBiG,GAC5B9G,KAAKkE,UAAY4C,EAEV9G,MAIRgH,OAAQ,WAKP,OAHAhH,KAAKkE,WAAc,EACnBlE,KAAKiE,OAAO+C,SAELhH,MAIRyB,gBAAiB,SAAWJ,GAE3B,OAAOrB,KAAKiE,OAAOzC,IAAKH,GAAUrB,KAAKkE,UAIxC+C,iBAAkB,SAAW7D,GAE5B,OAAOpD,KAAKyB,gBAAiB2B,EAAOC,QAAWD,EAAOK,QAIvDyD,aAAc,SAAW7F,EAAOT,GAS/B,YAPgBX,IAAXW,IAGJA,EAAS,IAAItB,GAIPsB,EAAON,KAAMN,KAAKiE,QAASpD,gBAAkBb,KAAKyB,gBAAiBJ,IAAUP,IAAKO,IAI1F8F,cAAe,SAAWC,EAAMxG,QAEfX,IAAXW,IAGJA,EAAS,IAAItB,GAId,MAAMS,EAAYqH,EAAKC,MAAOjB,GAExBpC,EAAchE,KAAKiE,OAAOzC,IAAKzB,GAErC,GAAqB,IAAhBiE,EAGJ,OAA4C,IAAvChE,KAAKyB,gBAAiB2F,EAAKE,OAExB1G,EAAON,KAAM8G,EAAKE,YAK1B,EAID,MAAM3G,IAAQyG,EAAKE,MAAM9F,IAAKxB,KAAKiE,QAAWjE,KAAKkE,UAAaF,EAEhE,OAAKrD,EAAI,GAAKA,EAAI,OAAlB,EAMOC,EAAON,KAAMP,GAAYc,eAAgBF,GAAIG,IAAKsG,EAAKE,QAI/DC,eAAgB,SAAWH,GAI1B,MAAMI,EAAYxH,KAAKyB,gBAAiB2F,EAAKE,OACvCG,EAAUzH,KAAKyB,gBAAiB2F,EAAKM,KAE3C,OAASF,EAAY,GAAKC,EAAU,GAASA,EAAU,GAAKD,EAAY,GAIzEpC,cAAe,SAAWb,GAEzB,OAAOA,EAAIH,gBAAiBpE,OAI7B6D,iBAAkB,SAAWT,GAE5B,OAAOA,EAAOgB,gBAAiBpE,OAIhC2H,cAAe,SAAW/G,GASzB,YAPgBX,IAAXW,IAGJA,EAAS,IAAItB,GAIPsB,EAAON,KAAMN,KAAKiE,QAASpD,gBAAkBb,KAAKkE,WAI1D8B,aAAc,SAAW4B,EAAQC,GAEhC,MAAMC,EAAeD,GAAwBvB,EAAcyB,gBAAiBH,GAEtEI,EAAiBhI,KAAK2H,cAAevB,GAAWJ,aAAc4B,GAE9D3D,EAASjE,KAAKiE,OAAOgE,aAAcH,GAAe5G,YAIxD,OAFAlB,KAAKkE,UAAa8D,EAAexG,IAAKyC,GAE/BjE,MAIRkI,UAAW,SAAWC,GAIrB,OAFAnI,KAAKkE,UAAYiE,EAAO3G,IAAKxB,KAAKiE,QAE3BjE,MAIRmG,OAAQ,SAAWpC,GAElB,OAAOA,EAAME,OAAOkC,OAAQnG,KAAKiE,SAAcF,EAAMG,WAAalE,KAAKkE,YCxNzE,MAAMkE,EAAM,IAAI9I,EACV+I,EAAM,IAAI/I,EACVgJ,EAAM,IAAIhJ,EACViJ,EAAM,IAAIjJ,EAEVkJ,EAAO,IAAIlJ,EACXmJ,EAAO,IAAInJ,EACXoJ,EAAO,IAAIpJ,EACXqJ,EAAO,IAAIrJ,EACXsJ,EAAO,IAAItJ,EACXuJ,EAAO,IAAIvJ,EAEjB,SAASwJ,EAAUxD,EAAGC,EAAG/C,GAExBxC,KAAKsF,OAAYrF,IAANqF,EAAoBA,EAAI,IAAIhG,EACvCU,KAAKuF,OAAYtF,IAANsF,EAAoBA,EAAI,IAAIjG,EACvCU,KAAKwC,OAAYvC,IAANuC,EAAoBA,EAAI,IAAIlD,EAIxCY,OAAOC,OAAQ2I,EAAU,CAExBC,UAAW,SAAWzD,EAAGC,EAAG/C,EAAG5B,QAEdX,IAAXW,IAGJA,EAAS,IAAItB,GAIdsB,EAAOU,WAAYkB,EAAG+C,GACtB6C,EAAI9G,WAAYgE,EAAGC,GACnB3E,EAAOkF,MAAOsC,GAEd,MAAMY,EAAiBpI,EAAO6B,WAC9B,OAAKuG,EAAiB,EAEdpI,EAAOC,eAAgB,EAAIa,KAAKC,KAAMqH,IAIvCpI,EAAOP,IAAK,EAAG,EAAG,IAM1B4I,aAAc,SAAW5H,EAAOiE,EAAGC,EAAG/C,EAAG5B,GAExCwH,EAAI9G,WAAYkB,EAAG8C,GACnB+C,EAAI/G,WAAYiE,EAAGD,GACnBgD,EAAIhH,WAAYD,EAAOiE,GAEvB,MAAM4D,EAAQd,EAAI5G,IAAK4G,GACjBe,EAAQf,EAAI5G,IAAK6G,GACjBe,EAAQhB,EAAI5G,IAAK8G,GACjBe,EAAQhB,EAAI7G,IAAK6G,GACjBiB,EAAQjB,EAAI7G,IAAK8G,GAEjBiB,EAAUL,EAAQG,EAAQF,EAAQA,EAUxC,QARgBlJ,IAAXW,IAGJA,EAAS,IAAItB,GAKC,IAAViK,EAIJ,OAAO3I,EAAOP,KAAO,GAAK,GAAK,GAIhC,MAAMmJ,EAAW,EAAID,EACfE,GAAMJ,EAAQD,EAAQD,EAAQG,GAAUE,EACxCxI,GAAMkI,EAAQI,EAAQH,EAAQC,GAAUI,EAG9C,OAAO5I,EAAOP,IAAK,EAAIoJ,EAAIzI,EAAGA,EAAGyI,IAIlCC,cAAe,SAAWrI,EAAOiE,EAAGC,EAAG/C,GAItC,OAFAsG,EAASG,aAAc5H,EAAOiE,EAAGC,EAAG/C,EAAG+F,GAE9BA,EAAIxD,GAAK,GAASwD,EAAItD,GAAK,GAAWsD,EAAIxD,EAAIwD,EAAItD,GAAO,GAInE0E,MAAO,SAAWtI,EAAOuI,EAAIC,EAAIC,EAAIC,EAAKC,EAAKC,EAAKrJ,GASnD,OAPAZ,KAAKiJ,aAAc5H,EAAOuI,EAAIC,EAAIC,EAAIvB,GAEtC3H,EAAOP,IAAK,EAAG,GACfO,EAAOsJ,gBAAiBH,EAAKxB,EAAIxD,GACjCnE,EAAOsJ,gBAAiBF,EAAKzB,EAAItD,GACjCrE,EAAOsJ,gBAAiBD,EAAK1B,EAAIpD,GAE1BvE,GAIRuJ,cAAe,SAAW7E,EAAGC,EAAG/C,EAAGzC,GAMlC,OAJAqI,EAAI9G,WAAYkB,EAAG+C,GACnB8C,EAAI/G,WAAYgE,EAAGC,GAGV6C,EAAItC,MAAOuC,GAAM7G,IAAKzB,GAAc,KAM/CG,OAAOC,OAAQ2I,EAAS1I,UAAW,CAElCC,IAAK,SAAWiF,EAAGC,EAAG/C,GAMrB,OAJAxC,KAAKsF,EAAEhF,KAAMgF,GACbtF,KAAKuF,EAAEjF,KAAMiF,GACbvF,KAAKwC,EAAElC,KAAMkC,GAENxC,MAIRoK,wBAAyB,SAAWC,EAAQC,EAAIC,EAAIC,GAMnD,OAJAxK,KAAKsF,EAAEhF,KAAM+J,EAAQC,IACrBtK,KAAKuF,EAAEjF,KAAM+J,EAAQE,IACrBvK,KAAKwC,EAAElC,KAAM+J,EAAQG,IAEdxK,MAIRO,MAAO,WAEN,OAAO,IAAIP,KAAKQ,aAAcF,KAAMN,OAIrCM,KAAM,SAAWmK,GAMhB,OAJAzK,KAAKsF,EAAEhF,KAAMmK,EAASnF,GACtBtF,KAAKuF,EAAEjF,KAAMmK,EAASlF,GACtBvF,KAAKwC,EAAElC,KAAMmK,EAASjI,GAEfxC,MAIR0K,QAAS,WAKR,OAHAtC,EAAI9G,WAAYtB,KAAKwC,EAAGxC,KAAKuF,GAC7B8C,EAAI/G,WAAYtB,KAAKsF,EAAGtF,KAAKuF,GAEM,GAA5B6C,EAAItC,MAAOuC,GAAMtB,UAIzB4D,YAAa,SAAW/J,GASvB,YAPgBX,IAAXW,IAGJA,EAAS,IAAItB,GAIPsB,EAAOgK,WAAY5K,KAAKsF,EAAGtF,KAAKuF,GAAIzE,IAAKd,KAAKwC,GAAI3B,eAAgB,EAAI,IAI9EkI,UAAW,SAAWnI,GAErB,OAAOkI,EAASC,UAAW/I,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,EAAG5B,IAIpDiK,SAAU,SAAWjK,GASpB,YAPgBX,IAAXW,IAGJA,EAAS,IAAI4F,GAIP5F,EAAOiG,sBAAuB7G,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,IAI3DyG,aAAc,SAAW5H,EAAOT,GAE/B,OAAOkI,EAASG,aAAc5H,EAAOrB,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,EAAG5B,IAI9D+I,MAAO,SAAWtI,EAAO0I,EAAKC,EAAKC,EAAKrJ,GAEvC,OAAOkI,EAASa,MAAOtI,EAAOrB,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,EAAGuH,EAAKC,EAAKC,EAAKrJ,IAItE8I,cAAe,SAAWrI,GAEzB,OAAOyH,EAASY,cAAerI,EAAOrB,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,IAI5D2H,cAAe,SAAWpK,GAEzB,OAAO+I,EAASqB,cAAenK,KAAKsF,EAAGtF,KAAKuF,EAAGvF,KAAKwC,EAAGzC,IAIxDqF,cAAe,SAAWb,GAEzB,OAAOA,EAAIuG,mBAAoB9K,OAIhCoB,oBAAqB,SAAW2J,EAAGnK,QAElBX,IAAXW,IAGJA,EAAS,IAAItB,GAId,MAAMgG,EAAItF,KAAKsF,EAAGC,EAAIvF,KAAKuF,EAAG/C,EAAIxC,KAAKwC,EACvC,IAAIxB,EAAG2F,EAQP6B,EAAKlH,WAAYiE,EAAGD,GACpBmD,EAAKnH,WAAYkB,EAAG8C,GACpBqD,EAAKrH,WAAYyJ,EAAGzF,GACpB,MAAM0F,EAAKxC,EAAKhH,IAAKmH,GACfpF,EAAKkF,EAAKjH,IAAKmH,GACrB,GAAKqC,GAAM,GAAKzH,GAAM,EAGrB,OAAO3C,EAAON,KAAMgF,GAIrBsD,EAAKtH,WAAYyJ,EAAGxF,GACpB,MAAM0F,EAAKzC,EAAKhH,IAAKoH,GACfsC,EAAKzC,EAAKjH,IAAKoH,GACrB,GAAKqC,GAAM,GAAKC,GAAMD,EAGrB,OAAOrK,EAAON,KAAMiF,GAIrB,MAAM4F,EAAKH,EAAKE,EAAKD,EAAK1H,EAC1B,GAAK4H,GAAM,GAAKH,GAAM,GAAKC,GAAM,EAIhC,OAFAjK,EAAIgK,GAAOA,EAAKC,GAETrK,EAAON,KAAMgF,GAAI4E,gBAAiB1B,EAAMxH,GAIhD6H,EAAKvH,WAAYyJ,EAAGvI,GACpB,MAAM4I,EAAK5C,EAAKhH,IAAKqH,GACfwC,EAAK5C,EAAKjH,IAAKqH,GACrB,GAAKwC,GAAM,GAAKD,GAAMC,EAGrB,OAAOzK,EAAON,KAAMkC,GAIrB,MAAM8I,EAAKF,EAAK7H,EAAKyH,EAAKK,EAC1B,GAAKC,GAAM,GAAK/H,GAAM,GAAK8H,GAAM,EAIhC,OAFA1E,EAAIpD,GAAOA,EAAK8H,GAETzK,EAAON,KAAMgF,GAAI4E,gBAAiBzB,EAAM9B,GAIhD,MAAM4E,EAAKN,EAAKI,EAAKD,EAAKF,EAC1B,GAAKK,GAAM,GAAOL,EAAKD,GAAQ,GAAOG,EAAKC,GAAQ,EAKlD,OAHA3C,EAAKpH,WAAYkB,EAAG+C,GACpBoB,GAAMuE,EAAKD,IAAWC,EAAKD,GAASG,EAAKC,IAElCzK,EAAON,KAAMiF,GAAI2E,gBAAiBxB,EAAM/B,GAKhD,MAAM4C,EAAQ,GAAMgC,EAAKD,EAAKH,GAK9B,OAHAnK,EAAIsK,EAAK/B,EACT5C,EAAIwE,EAAK5B,EAEF3I,EAAON,KAAMgF,GAAI4E,gBAAiB1B,EAAMxH,GAAIkJ,gBAAiBzB,EAAM9B,IAI3ER,OAAQ,SAAWsE,GAElB,OAAOA,EAASnF,EAAEa,OAAQnG,KAAKsF,IAAOmF,EAASlF,EAAEY,OAAQnG,KAAKuF,IAAOkF,EAASjI,EAAE2D,OAAQnG,KAAKwC"}