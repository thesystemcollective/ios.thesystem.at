import{V as t,a as n}from"./Object3D.js";const i=new t,o=new t,s=new t,r=new t,e=new t,c=new t,a=new t;function u(n,i){this.origin=void 0!==n?n:new t,this.direction=void 0!==i?i:new t(0,0,-1)}Object.assign(u.prototype,{set:function(t,n){return this.origin.copy(t),this.direction.copy(n),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this},at:function(n,i){return void 0===i&&(i=new t),i.copy(this.direction).multiplyScalar(n).add(this.origin)},lookAt:function(t){return this.direction.copy(t).sub(this.origin).normalize(),this},recast:function(t){return this.origin.copy(this.at(t,i)),this},closestPointToPoint:function(n,i){void 0===i&&(i=new t),i.subVectors(n,this.origin);const o=i.dot(this.direction);return o<0?i.copy(this.origin):i.copy(this.direction).multiplyScalar(o).add(this.origin)},distanceToPoint:function(t){return Math.sqrt(this.distanceSqToPoint(t))},distanceSqToPoint:function(t){const n=i.subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):(i.copy(this.direction).multiplyScalar(n).add(this.origin),i.distanceToSquared(t))},distanceSqToSegment:function(t,n,i,e){o.copy(t).add(n).multiplyScalar(.5),s.copy(n).sub(t).normalize(),r.copy(this.origin).sub(o);const c=.5*t.distanceTo(n),a=-this.direction.dot(s),u=r.dot(this.direction),h=-r.dot(s),l=r.lengthSq(),d=Math.abs(1-a*a);let p,f,y,m;if(d>0)if(p=a*h-u,f=a*u-h,m=c*d,p>=0)if(f>=-m)if(f<=m){const t=1/d;p*=t,f*=t,y=p*(p+a*f+2*u)+f*(a*p+f+2*h)+l}else f=c,p=Math.max(0,-(a*f+u)),y=-p*p+f*(f+2*h)+l;else f=-c,p=Math.max(0,-(a*f+u)),y=-p*p+f*(f+2*h)+l;else f<=-m?(p=Math.max(0,-(-a*c+u)),f=p>0?-c:Math.min(Math.max(-c,-h),c),y=-p*p+f*(f+2*h)+l):f<=m?(p=0,f=Math.min(Math.max(-c,-h),c),y=f*(f+2*h)+l):(p=Math.max(0,-(a*c+u)),f=p>0?c:Math.min(Math.max(-c,-h),c),y=-p*p+f*(f+2*h)+l);else f=a>0?-c:c,p=Math.max(0,-(a*f+u)),y=-p*p+f*(f+2*h)+l;return i&&i.copy(this.direction).multiplyScalar(p).add(this.origin),e&&e.copy(s).multiplyScalar(f).add(o),y},intersectSphere:function(t,n){i.subVectors(t.center,this.origin);const o=i.dot(this.direction),s=i.dot(i)-o*o,r=t.radius*t.radius;if(s>r)return null;const e=Math.sqrt(r-s),c=o-e,a=o+e;return c<0&&a<0?null:c<0?this.at(a,n):this.at(c,n)},intersectsSphere:function(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius},distanceToPlane:function(t){const n=t.normal.dot(this.direction);if(0===n)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/n;return i>=0?i:null},intersectPlane:function(t,n){const i=this.distanceToPlane(t);return null===i?null:this.at(i,n)},intersectsPlane:function(t){const n=t.distanceToPoint(this.origin);if(0===n)return!0;return t.normal.dot(this.direction)*n<0},intersectBox:function(t,n){let i,o,s,r,e,c;const a=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,l=this.origin;return a>=0?(i=(t.min.x-l.x)*a,o=(t.max.x-l.x)*a):(i=(t.max.x-l.x)*a,o=(t.min.x-l.x)*a),u>=0?(s=(t.min.y-l.y)*u,r=(t.max.y-l.y)*u):(s=(t.max.y-l.y)*u,r=(t.min.y-l.y)*u),i>r||s>o?null:((s>i||i!=i)&&(i=s),(r<o||o!=o)&&(o=r),h>=0?(e=(t.min.z-l.z)*h,c=(t.max.z-l.z)*h):(e=(t.max.z-l.z)*h,c=(t.min.z-l.z)*h),i>c||e>o?null:((e>i||i!=i)&&(i=e),(c<o||o!=o)&&(o=c),o<0?null:this.at(i>=0?i:o,n)))},intersectsBox:function(t){return null!==this.intersectBox(t,i)},intersectTriangle:function(t,n,i,o,s){e.subVectors(n,t),c.subVectors(i,t),a.crossVectors(e,c);let u,h=this.direction.dot(a);if(h>0){if(o)return null;u=1}else{if(!(h<0))return null;u=-1,h=-h}r.subVectors(this.origin,t);const l=u*this.direction.dot(c.crossVectors(r,c));if(l<0)return null;const d=u*this.direction.dot(e.cross(r));if(d<0)return null;if(l+d>h)return null;const p=-u*r.dot(a);return p<0?null:this.at(p/h,s)},applyMatrix4:function(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this},equals:function(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}});const h=new t,l=new t,d=new n;function p(n,i){this.normal=void 0!==n?n:new t(1,0,0),this.constant=void 0!==i?i:0}Object.assign(p.prototype,{isPlane:!0,set:function(t,n){return this.normal.copy(t),this.constant=n,this},setComponents:function(t,n,i,o){return this.normal.set(t,n,i),this.constant=o,this},setFromNormalAndCoplanarPoint:function(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this},setFromCoplanarPoints:function(t,n,i){const o=h.subVectors(i,n).cross(l.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(o,t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this},normalize:function(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(t){return this.normal.dot(t)+this.constant},distanceToSphere:function(t){return this.distanceToPoint(t.center)-t.radius},projectPoint:function(n,i){return void 0===i&&(i=new t),i.copy(this.normal).multiplyScalar(-this.distanceToPoint(n)).add(n)},intersectLine:function(n,i){void 0===i&&(i=new t);const o=n.delta(h),s=this.normal.dot(o);if(0===s)return 0===this.distanceToPoint(n.start)?i.copy(n.start):void 0;const r=-(n.start.dot(this.normal)+this.constant)/s;return r<0||r>1?void 0:i.copy(o).multiplyScalar(r).add(n.start)},intersectsLine:function(t){const n=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return n<0&&i>0||i<0&&n>0},intersectsBox:function(t){return t.intersectsPlane(this)},intersectsSphere:function(t){return t.intersectsPlane(this)},coplanarPoint:function(n){return void 0===n&&(n=new t),n.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(t,n){const i=n||d.getNormalMatrix(t),o=this.coplanarPoint(h).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-o.dot(s),this},translate:function(t){return this.constant-=t.dot(this.normal),this},equals:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant}});const f=new t,y=new t,m=new t,g=new t,b=new t,w=new t,x=new t,V=new t,P=new t,S=new t;function T(n,i,o){this.a=void 0!==n?n:new t,this.b=void 0!==i?i:new t,this.c=void 0!==o?o:new t}Object.assign(T,{getNormal:function(n,i,o,s){void 0===s&&(s=new t),s.subVectors(o,i),f.subVectors(n,i),s.cross(f);const r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)},getBarycoord:function(n,i,o,s,r){f.subVectors(s,i),y.subVectors(o,i),m.subVectors(n,i);const e=f.dot(f),c=f.dot(y),a=f.dot(m),u=y.dot(y),h=y.dot(m),l=e*u-c*c;if(void 0===r&&(r=new t),0===l)return r.set(-2,-1,-1);const d=1/l,p=(u*a-c*h)*d,g=(e*h-c*a)*d;return r.set(1-p-g,g,p)},containsPoint:function(t,n,i,o){return T.getBarycoord(t,n,i,o,g),g.x>=0&&g.y>=0&&g.x+g.y<=1},getUV:function(t,n,i,o,s,r,e,c){return this.getBarycoord(t,n,i,o,g),c.set(0,0),c.addScaledVector(s,g.x),c.addScaledVector(r,g.y),c.addScaledVector(e,g.z),c},isFrontFacing:function(t,n,i,o){return f.subVectors(i,n),y.subVectors(t,n),f.cross(y).dot(o)<0}}),Object.assign(T.prototype,{set:function(t,n,i){return this.a.copy(t),this.b.copy(n),this.c.copy(i),this},setFromPointsAndIndices:function(t,n,i,o){return this.a.copy(t[n]),this.b.copy(t[i]),this.c.copy(t[o]),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this},getArea:function(){return f.subVectors(this.c,this.b),y.subVectors(this.a,this.b),.5*f.cross(y).length()},getMidpoint:function(n){return void 0===n&&(n=new t),n.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(t){return T.getNormal(this.a,this.b,this.c,t)},getPlane:function(t){return void 0===t&&(t=new p),t.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(t,n){return T.getBarycoord(t,this.a,this.b,this.c,n)},getUV:function(t,n,i,o,s){return T.getUV(t,this.a,this.b,this.c,n,i,o,s)},containsPoint:function(t){return T.containsPoint(t,this.a,this.b,this.c)},isFrontFacing:function(t){return T.isFrontFacing(this.a,this.b,this.c,t)},intersectsBox:function(t){return t.intersectsTriangle(this)},closestPointToPoint:function(n,i){void 0===i&&(i=new t);const o=this.a,s=this.b,r=this.c;let e,c;b.subVectors(s,o),w.subVectors(r,o),V.subVectors(n,o);const a=b.dot(V),u=w.dot(V);if(a<=0&&u<=0)return i.copy(o);P.subVectors(n,s);const h=b.dot(P),l=w.dot(P);if(h>=0&&l<=h)return i.copy(s);const d=a*l-h*u;if(d<=0&&a>=0&&h<=0)return e=a/(a-h),i.copy(o).addScaledVector(b,e);S.subVectors(n,r);const p=b.dot(S),f=w.dot(S);if(f>=0&&p<=f)return i.copy(r);const y=p*u-a*f;if(y<=0&&u>=0&&f<=0)return c=u/(u-f),i.copy(o).addScaledVector(w,c);const m=h*f-p*l;if(m<=0&&l-h>=0&&p-f>=0)return x.subVectors(r,s),c=(l-h)/(l-h+(p-f)),i.copy(s).addScaledVector(x,c);const g=1/(m+y+d);return e=y*g,c=d*g,i.copy(o).addScaledVector(b,e).addScaledVector(w,c)},equals:function(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}});export{p as P,u as R,T};
//# sourceMappingURL=Triangle.js.map
