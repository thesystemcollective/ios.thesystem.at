{"version":3,"file":"Geometry.js","sources":["../../node_modules/three/src/core/Geometry.js"],"sourcesContent":["import { EventDispatcher } from './EventDispatcher.js';\nimport { Face3 } from './Face3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from './Object3D.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nlet _geometryId = 0; // Geometry uses even numbers as Id\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\n\nfunction Geometry() {\n\n\tObject.defineProperty( this, 'id', { value: _geometryId += 2 } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tconst scope = this;\n\n\t\tconst index = geometry.index !== null ? geometry.index : undefined;\n\t\tconst attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst position = attributes.position;\n\t\tconst normal = attributes.normal;\n\t\tconst color = attributes.color;\n\t\tconst uv = attributes.uv;\n\t\tconst uv2 = attributes.uv2;\n\n\t\tif ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n\n\t\t\tif ( color !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromBufferAttribute( color, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tconst vertexColors = ( color === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone()\n\t\t\t];\n\n\t\t\tconst vertexNormals = ( normal === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, a ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, b ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, c )\n\t\t\t];\n\n\t\t\tconst face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uv !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uv2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\taddFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\t\taddFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tconst center = this.boundingSphere.center;\n\t\tconst radius = this.boundingSphere.radius;\n\n\t\tconst s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tconst vertices = new Array( this.vertices.length );\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tconst tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tconst dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tconst dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tconst faceNormal = new Vector3();\n\t\t\t\t\tconst vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst faceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tconst vertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( let i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = vertices2[ i ];\n\n\t\t\tconst vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( let i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( let i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tlet face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tconst verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tconst unique = [], changes = [];\n\n\t\tconst precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst v = this.vertices[ i ];\n\t\t\tconst key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tconst faceIndicesToRemove = [];\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tconst indices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tconst diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tconst faces = this.faces;\n\t\tconst length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tconst uvs1 = this.faceVertexUvs[ 0 ];\n\t\tconst uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tlet newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tconst vertices = [];\n\n\t\tfor ( let i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tconst faces = [];\n\t\tconst normals = [];\n\t\tconst normalsHash = {};\n\t\tconst colors = [];\n\t\tconst colorsHash = {};\n\t\tconst uvs = [];\n\t\tconst uvsHash = {};\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tconst hasMaterial = true;\n\t\t\tconst hasFaceUv = false; // deprecated\n\t\t\tconst hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tconst hasFaceNormal = face.normal.length() > 0;\n\t\t\tconst hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tconst hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tconst hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tlet faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tconst faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tconst hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tconst hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tconst hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tconst vertices = source.vertices;\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tconst colors = source.colors;\n\n\t\tfor ( let i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tconst faces = source.faces;\n\n\t\tfor ( let i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphTargets = source.morphTargets;\n\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tconst morphNormals = source.morphNormals;\n\n\t\tfor ( let i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tconst morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tconst destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tconst skinWeights = source.skinWeights;\n\n\t\tfor ( let i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tconst skinIndices = source.skinIndices;\n\n\t\tfor ( let i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tconst lineDistances = source.lineDistances;\n\n\t\tfor ( let i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { Geometry };\n"],"names":["_geometryId","_m1","Matrix4","_obj","Object3D","_offset","Vector3","Geometry","Object","defineProperty","this","value","uuid","MathUtils","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","prototype","assign","create","EventDispatcher","constructor","isGeometry","applyMatrix4","matrix","normalMatrix","Matrix3","getNormalMatrix","i","il","length","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","undefined","attributes","position","color","uv","uv2","count","push","fromBufferAttribute","Color","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","Vector2","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","Box3","setFromPoints","Sphere","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","vertex","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","dispose","dispatchEvent"],"mappings":"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"}