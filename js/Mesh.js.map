{"version":3,"file":"Mesh.js","sources":["../../node_modules/three/src/math/Ray.js","../../node_modules/three/src/math/Plane.js","../../node_modules/three/src/math/Triangle.js","../../node_modules/three/src/objects/Mesh.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nconst _vector = new Vector3();\nconst _segCenter = new Vector3();\nconst _segDir = new Vector3();\nconst _diff = new Vector3();\n\nconst _edge1 = new Vector3();\nconst _edge2 = new Vector3();\nconst _normal = new Vector3();\n\nfunction Ray( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );\n\n}\n\nObject.assign( Ray.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function ( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t},\n\n\tclosestPointToPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function ( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t},\n\n\tdistanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t},\n\n\tintersectSphere: function ( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t},\n\n\tintersectPlane: function ( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t},\n\n\tintersectTriangle: function ( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t},\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n} );\n\n\nexport { Ray };\n","import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = new Vector3();\nconst _vector2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\nfunction Plane( normal, constant ) {\n\n\t// normal is assumed to be normalized\n\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n}\n\nObject.assign( Plane.prototype, {\n\n\tisPlane: true,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function ( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t},\n\n\tintersectLine: function ( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t},\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n} );\n\n\nexport { Plane };\n","import { Vector3 } from './Vector3.js';\nimport { Plane } from './Plane.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _v3 = new Vector3();\n\nconst _vab = new Vector3();\nconst _vac = new Vector3();\nconst _vbc = new Vector3();\nconst _vap = new Vector3();\nconst _vbp = new Vector3();\nconst _vcp = new Vector3();\n\nfunction Triangle( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n}\n\nObject.assign( Triangle, {\n\n\tgetNormal: function ( a, b, c, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0.subVectors( a, b );\n\t\ttarget.cross( _v0 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t},\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tgetBarycoord: function ( point, a, b, c, target ) {\n\n\t\t_v0.subVectors( c, a );\n\t\t_v1.subVectors( b, a );\n\t\t_v2.subVectors( point, a );\n\n\t\tconst dot00 = _v0.dot( _v0 );\n\t\tconst dot01 = _v0.dot( _v1 );\n\t\tconst dot02 = _v0.dot( _v2 );\n\t\tconst dot11 = _v1.dot( _v1 );\n\t\tconst dot12 = _v1.dot( _v2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t},\n\n\tcontainsPoint: function ( point, a, b, c ) {\n\n\t\tTriangle.getBarycoord( point, a, b, c, _v3 );\n\n\t\treturn ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );\n\n\t},\n\n\tgetUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3 );\n\n\t\ttarget.set( 0, 0 );\n\t\ttarget.addScaledVector( uv1, _v3.x );\n\t\ttarget.addScaledVector( uv2, _v3.y );\n\t\ttarget.addScaledVector( uv3, _v3.z );\n\n\t\treturn target;\n\n\t},\n\n\tisFrontFacing: function ( a, b, c, direction ) {\n\n\t\t_v0.subVectors( c, b );\n\t\t_v1.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tgetArea: function () {\n\n\t\t_v0.subVectors( this.c, this.b );\n\t\t_v1.subVectors( this.a, this.b );\n\n\t\treturn _v0.cross( _v1 ).length() * 0.5;\n\n\t},\n\n\tgetMidpoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tgetNormal: function ( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t},\n\n\tgetPlane: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Plane();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tgetBarycoord: function ( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t},\n\n\tgetUV: function ( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tisFrontFacing: function ( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t},\n\n\tclosestPointToPoint: function ( p, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t},\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n} );\n\n\nexport { Triangle };\n","import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Face3 } from '../core/Face3.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\n\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\n\nconst _tempA = new Vector3();\nconst _tempB = new Vector3();\nconst _tempC = new Vector3();\n\nconst _morphA = new Vector3();\nconst _morphB = new Vector3();\nconst _morphC = new Vector3();\n\nconst _uvA = new Vector2();\nconst _uvB = new Vector2();\nconst _uvC = new Vector2();\n\nconst _intersectionPoint = new Vector3();\nconst _intersectionPointWorld = new Vector3();\n\nfunction Mesh( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new MeshBasicMaterial();\n\n\tthis.updateMorphTargets();\n\n}\n\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Mesh,\n\n\tisMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.getInverse( matrixWorld );\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t// Check boundingBox before continuing\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\tlet intersection;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst uv = geometry.attributes.uv;\n\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconst isMultiMaterial = Array.isArray( material );\n\n\t\t\tconst vertices = geometry.vertices;\n\t\t\tconst faces = geometry.faces;\n\t\t\tlet uvs;\n\n\t\t\tconst faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\tfor ( let f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = faces[ f ];\n\t\t\t\tconst faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\n\n\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\tconst fvA = vertices[ face.a ];\n\t\t\t\tconst fvB = vertices[ face.b ];\n\t\t\t\tconst fvC = vertices[ face.c ];\n\n\t\t\t\tintersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs && uvs[ f ] ) {\n\n\t\t\t\t\t\tconst uvs_f = uvs[ f ];\n\t\t\t\t\t\t_uvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t_uvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t_uvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = face;\n\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst morphInfluences = object.morphTargetInfluences;\n\n\tif ( material.morphTargets && morphPosition && morphInfluences ) {\n\n\t\t_morphA.set( 0, 0, 0 );\n\t\t_morphB.set( 0, 0, 0 );\n\t\t_morphC.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\tconst influence = morphInfluences[ i ];\n\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_vA.add( _morphA );\n\t\t_vB.add( _morphB );\n\t\t_vC.add( _morphC );\n\n\t}\n\n\tif ( object.isSkinnedMesh ) {\n\n\t\tobject.boneTransform( a, _vA );\n\t\tobject.boneTransform( b, _vB );\n\t\tobject.boneTransform( c, _vC );\n\n\t}\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv2 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv2, a );\n\t\t\t_uvB.fromBufferAttribute( uv2, b );\n\t\t\t_uvC.fromBufferAttribute( uv2, c );\n\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tconst face = new Face3( a, b, c );\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nexport { Mesh };\n"],"names":["_vector","Vector3","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","origin","direction","this","undefined","Object","assign","prototype","set","copy","clone","constructor","ray","at","t","target","multiplyScalar","add","lookAt","v","sub","normalize","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","intersectsBox","intersectTriangle","a","b","backfaceCulling","crossVectors","sign","DdN","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","transformDirection","equals","_vector1","_vector2","_normalMatrix","Matrix3","Plane","isPlane","setComponents","w","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","length","negate","distanceToSphere","projectPoint","intersectLine","line","delta","start","intersectsLine","startSign","endSign","end","coplanarPoint","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","_v0","_v1","_v2","_v3","_vab","_vac","_vbc","_vap","_vbp","_vcp","Triangle","getNormal","targetLengthSq","getBarycoord","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","containsPoint","getUV","p1","p2","p3","uv1","uv2","uv3","addScaledVector","isFrontFacing","setFromPointsAndIndices","points","i0","i1","i2","triangle","getArea","getMidpoint","addVectors","getPlane","intersectsTriangle","p","d1","d3","d4","vc","d5","d6","vb","va","_inverseMatrix","Matrix4","_ray","_sphere","Sphere","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA","Vector2","_uvB","_uvC","_intersectionPoint","_intersectionPointWorld","Mesh","geometry","material","Object3D","call","type","BufferGeometry","MeshBasicMaterial","updateMorphTargets","checkIntersection","object","raycaster","pA","pB","pC","intersect","side","BackSide","DoubleSide","matrixWorld","distance","near","far","checkBufferGeometryIntersection","position","morphPosition","morphTargetsRelative","uv","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","i","il","influence","morphAttribute","isSkinnedMesh","boneTransform","intersection","face","Face3","create","isMesh","source","slice","morphTargetDictionary","isBufferGeometry","morphAttributes","keys","m","ml","name","String","push","raycast","intersects","boundingSphere","computeBoundingSphere","getInverse","boundingBox","index","attributes","groups","drawRange","Array","isArray","group","groupMaterial","materialIndex","j","jl","count","getX","faceIndex","floor","isGeometry","isMultiMaterial","vertices","faces","uvs","faceVertexUvs","f","fl","faceMaterial","fvA","fvB","fvC","uvs_f"],"mappings":"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"}