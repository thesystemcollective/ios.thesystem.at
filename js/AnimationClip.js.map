{"version":3,"file":"AnimationClip.js","sources":["../../node_modules/three/src/math/Interpolant.js","../../node_modules/three/src/math/interpolants/LinearInterpolant.js","../../node_modules/three/src/animation/PropertyBinding.js","../../node_modules/three/src/animation/AnimationUtils.js","../../node_modules/three/src/math/interpolants/CubicInterpolant.js","../../node_modules/three/src/math/interpolants/DiscreteInterpolant.js","../../node_modules/three/src/animation/KeyframeTrack.js","../../node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js","../../node_modules/three/src/animation/tracks/ColorKeyframeTrack.js","../../node_modules/three/src/animation/tracks/NumberKeyframeTrack.js","../../node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js","../../node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js","../../node_modules/three/src/animation/tracks/StringKeyframeTrack.js","../../node_modules/three/src/animation/tracks/VectorKeyframeTrack.js","../../node_modules/three/src/animation/AnimationClip.js"],"sourcesContent":["/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n}\n\nObject.assign( Interpolant.prototype, {\n\n\tevaluate: function ( t ) {\n\n\t\tlet pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function () {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function ( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n} );\n\n// DECLARE ALIAS AFTER assign prototype\nObject.assign( Interpolant.prototype, {\n\n\t//( 0, t, t0 ), returns this.resultBuffer\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t//( N-1, tN-1, t ), returns this.resultBuffer\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n} );\n\n\nexport { Interpolant };\n","import { Interpolant } from '../Interpolant.js';\n\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: LinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n\nexport { LinearInterpolant };\n","// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\nfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n}\n\nObject.assign( Composite.prototype, {\n\n\tgetValue: function ( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function ( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n} );\n\n\nfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n}\n\nObject.assign( PropertyBinding, {\n\n\tComposite: Composite,\n\n\tcreate: function ( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tsanitizeNodeName: function ( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t},\n\n\tparseTrackName: function ( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t},\n\n\tfindNode: function ( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n} );\n\nObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function () {},\n\t_setValue_unavailable: function () {},\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t],\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function () {\n\n\t\tlet targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function () {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n} );\n\n// DECLARE ALIAS AFTER assign prototype\nObject.assign( PropertyBinding.prototype, {\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n} );\n\nexport { PropertyBinding };\n","import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\nconst AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tconst n = times.length;\n\t\tconst result = new Array( n );\n\t\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tconst nValues = values.length;\n\t\tconst result = new values.constructor( nValues );\n\n\t\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tconst srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tlet i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tlet value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t},\n\n\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps ) {\n\n\t\tfps = fps || 30;\n\n\t\tconst clip = sourceClip.clone();\n\n\t\tclip.name = name;\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tconst track = clip.tracks[ i ];\n\t\t\tconst valueSize = track.getValueSize();\n\n\t\t\tconst times = [];\n\t\t\tconst values = [];\n\n\t\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( times.length === 0 ) continue;\n\n\t\t\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\n\t\t\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\t// find minimum .times value across all tracks in the trimmed clip\n\n\t\tlet minStartTime = Infinity;\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// shift all tracks such that clip begins at t=0\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t\t}\n\n\t\tclip.resetDuration();\n\n\t\treturn clip;\n\n\t},\n\n\tmakeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {\n\n\t\tif ( referenceFrame === undefined ) referenceFrame = 0;\n\t\tif ( referenceClip === undefined ) referenceClip = targetClip;\n\t\tif ( fps === undefined || fps <= 0 ) fps = 30;\n\n\t\tconst numTracks = targetClip.tracks.length;\n\t\tconst referenceTime = referenceFrame / fps;\n\n\t\t// Make each track's values relative to the values at the reference frame\n\t\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t\t// Skip this track if it's non-numeric\n\t\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t\t} );\n\n\t\t\tif ( targetTrack === undefined ) continue;\n\n\t\t\tconst valueSize = referenceTrack.getValueSize();\n\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\tlet referenceValue;\n\n\t\t\t// Find the value to subtract out of the track\n\t\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, 0, referenceTrack.valueSize );\n\n\t\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\tconst startIndex = lastIndex * valueSize;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex );\n\n\t\t\t} else {\n\n\t\t\t\t// Interpolate to the reference value\n\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\t\treferenceValue = interpolant.resultBuffer;\n\n\t\t\t}\n\n\t\t\t// Conjugate the quaternion\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\tconst referenceQuat = new Quaternion(\n\t\t\t\t\treferenceValue[ 0 ],\n\t\t\t\t\treferenceValue[ 1 ],\n\t\t\t\t\treferenceValue[ 2 ],\n\t\t\t\t\treferenceValue[ 3 ]\n\t\t\t\t).normalize().conjugate();\n\t\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t\t}\n\n\t\t\t// Subtract the reference value from all of the track values\n\n\t\t\tconst numTimes = targetTrack.times.length;\n\t\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\t\tconst valueStart = j * valueSize;\n\n\t\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart,\n\t\t\t\t\t\treferenceValue,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\t\treturn targetClip;\n\n\t}\n\n};\n\nexport { AnimationUtils };\n","import { ZeroCurvatureEnding } from '../../constants.js';\nimport { Interpolant } from '../Interpolant.js';\nimport { WrapAroundEnding, ZeroSlopeEnding } from '../../constants.js';\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = - 0;\n\tthis._offsetPrev = - 0;\n\tthis._weightNext = - 0;\n\tthis._offsetNext = - 0;\n\n}\n\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\tlet pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n\nexport { CubicInterpolant };\n","import { Interpolant } from '../Interpolant.js';\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n */\n\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: DiscreteInterpolant,\n\n\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n\nexport { DiscreteInterpolant };\n","import {\n\tInterpolateLinear,\n\tInterpolateSmooth,\n\tInterpolateDiscrete\n} from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport { AnimationUtils } from './AnimationUtils.js';\n\nfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\tthis.name = name;\n\n\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n}\n\n// Static methods\n\nObject.assign( KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\ttoJSON: function ( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n} );\n\nObject.assign( KeyframeTrack.prototype, {\n\n\tconstructor: KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function ( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function ( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = \"unsupported interpolation for \" +\n\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t},\n\n\tgetInterpolation: function () {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function () {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function ( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function ( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function ( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function () {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function () {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n} );\n\nexport { KeyframeTrack };\n","import { InterpolateDiscrete } from '../../constants.js';\nimport { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of Boolean keyframe values.\n */\n\nfunction BooleanKeyframeTrack( name, times, values ) {\n\n\tKeyframeTrack.call( this, name, times, values );\n\n}\n\nBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\nexport { BooleanKeyframeTrack };\n","import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of keyframe values that represent color.\n */\n\nfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\nexport { ColorKeyframeTrack };\n","import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of numeric keyframe values.\n */\n\nfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: NumberKeyframeTrack,\n\n\tValueTypeName: 'number'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\nexport { NumberKeyframeTrack };\n","import { Interpolant } from '../Interpolant.js';\nimport { Quaternion } from '../Quaternion.js';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: QuaternionLinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n\nexport { QuaternionLinearInterpolant };\n","import { InterpolateLinear } from '../../constants.js';\nimport { KeyframeTrack } from '../KeyframeTrack.js';\nimport { QuaternionLinearInterpolant } from '../../math/interpolants/QuaternionLinearInterpolant.js';\n\n/**\n * A Track of quaternion keyframe values.\n */\n\nfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\nexport { QuaternionKeyframeTrack };\n","import { InterpolateDiscrete } from '../../constants.js';\nimport { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track that interpolates Strings\n */\n\nfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\nexport { StringKeyframeTrack };\n","import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of vectored keyframe values.\n */\n\nfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\nexport { VectorKeyframeTrack };\n","import { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationClip( name, duration, tracks, blendMode ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\tthis.blendMode = ( blendMode !== undefined ) ? blendMode : NormalAnimationBlendMode;\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nObject.assign( AnimationClip, {\n\n\tparse: function ( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( json.name, json.duration, tracks, json.blendMode );\n\n\t},\n\n\ttoJSON: function ( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t},\n\n\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function ( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new AnimationClip( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\nObject.assign( AnimationClip.prototype, {\n\n\tresetDuration: function () {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t},\n\n\ttrim: function () {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tvalidate: function () {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\toptimize: function () {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new AnimationClip( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n} );\n\n\nexport { AnimationClip };\n"],"names":["Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","this","_cachedIndex","undefined","constructor","valueSize","LinearInterpolant","call","Object","assign","prototype","evaluate","t","pp","i1","t1","t0","validate_interval","seek","right","linear_scan","forward_scan","giveUpAt","length","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","index","result","values","stride","offset","i","Error","create","offset1","offset0","weight1","weight0","_reservedRe","RegExp","_wordCharOrDot","replace","_directoryRe","source","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","Composite","targetGroup","path","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","rootNode","node","findNode","nodeName","getValue","array","bind","firstValidIndex","nCachedObjects_","binding","setValue","bindings","n","unbind","root","isAnimationObjectGroup","sanitizeNodeName","name","trackName","matches","exec","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","indexOf","uuid","skeleton","bone","getBoneByName","children","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","BindingType","Direct","EntireArray","ArrayElement","HasFromToArray","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","GetterByBindingType","buffer","resolvedProperty","toArray","SetterByBindingTypeAndVersioning","targetObject","needsUpdate","matrixWorldNeedsUpdate","dest","fromArray","targetArray","sourceArray","material","materials","bones","nodeProperty","versioning","bindingType","geometry","isBufferGeometry","morphAttributes","morphTargetDictionary","Array","isArray","_getValue_unbound","_setValue_unbound","AnimationUtils","arraySlice","from","to","isTypedArray","subarray","slice","convertArray","type","forceClone","BYTES_PER_ELEMENT","object","ArrayBuffer","isView","DataView","getKeyframeOrder","times","sort","j","sortedArray","order","nValues","dstOffset","srcOffset","flattenJSON","jsonKeys","valuePropertyName","key","value","push","time","apply","subclip","sourceClip","startFrame","endFrame","fps","clip","clone","tracks","track","getValueSize","frame","k","minStartTime","Infinity","shift","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","lastIndex","referenceValue","startIndex","interpolant","createInterpolant","Quaternion","normalize","conjugate","numTimes","valueStart","multiplyQuaternionsFlat","blendMode","AdditiveAnimationBlendMode","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","DiscreteInterpolant","KeyframeTrack","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","AnimationClip","duration","NormalAnimationBlendMode","MathUtils","generateUUID","parseKeyframeTrack","json","trackType","typeName","toLowerCase","getTrackTypeForValueTypeName","keys","parse","endingStart","ZeroCurvatureEnding","endingEnd","iPrev","iNext","tPrev","tNext","ZeroSlopeEnding","WrapAroundEnding","halfDt","o1","o0","oP","oN","wP","wN","p","ppp","sP","s0","s1","sN","toJSON","getInterpolation","Float32Array","InterpolateLinear","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","InterpolateDiscrete","InterpolateSmooth","message","timeOffset","scale","timeScale","trim","startTime","endTime","nKeys","Math","max","validate","valid","floor","prevTime","currTime","isNaN","optimize","smoothInterpolation","writeIndex","keep","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","alpha","end","slerpFlat","jsonTracks","frameTime","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","o","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","addNonemptyTrack","animationKeys","destTracks","clipName","hierarchyTracks","hierarchy","h","morphTargetNames","m","morphTargetName","animationKey","boneName"],"mappings":"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"}