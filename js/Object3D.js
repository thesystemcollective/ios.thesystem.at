import{M as t,E as s}from"./MathUtils.js";import{Q as e}from"./Quaternion.js";class i{constructor(t=0,s=0,e=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=s,this.z=e}set(t,s,e){return void 0===e&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?this.addVectors(t,s):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?this.subVectors(t,s):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?this.multiplyVectors(t,s):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return!t||t.isEuler,this.applyQuaternion(n.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(n.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[3]*e+r[6]*i,this.y=r[1]*s+r[4]*e+r[7]*i,this.z=r[2]*s+r[5]*e+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,r=t.elements,n=1/(r[3]*s+r[7]*e+r[11]*i+r[15]);return this.x=(r[0]*s+r[4]*e+r[8]*i+r[12])*n,this.y=(r[1]*s+r[5]*e+r[9]*i+r[13])*n,this.z=(r[2]*s+r[6]*e+r[10]*i+r[14])*n,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,r=t.x,n=t.y,h=t.z,a=t.w,o=a*s+n*i-h*e,l=a*e+h*s-r*i,u=a*i+r*e-n*s,c=-r*s-n*e-h*i;return this.x=o*a+c*-r+l*-h-u*-n,this.y=l*a+c*-n+u*-r-o*-h,this.z=u*a+c*-h+o*-n-l*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,r=t.elements;return this.x=r[0]*s+r[4]*e+r[8]*i,this.y=r[1]*s+r[5]*e+r[9]*i,this.z=r[2]*s+r[6]*e+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(t,Math.min(s,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t,s){return void 0!==s?this.crossVectors(t,s):this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,r=t.z,n=s.x,h=s.y,a=s.z;return this.x=i*a-r*h,this.y=r*n-e*a,this.z=e*h-i*n,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return r.copy(this).projectOnVector(t),this.sub(r)}reflect(t){return this.sub(r.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(s){const e=Math.sqrt(this.lengthSq()*s.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(s)/e;return Math.acos(t.clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s){return void 0===s&&(s=0),this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t,s){return void 0===t&&(t=[]),void 0===s&&(s=0),t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,e){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const r=new i,n=new e;class h{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,s,e,i,r,n,h,a,o,l,u,c,m,x,d,y){const p=this.elements;return p[0]=t,p[4]=s,p[8]=e,p[12]=i,p[1]=r,p[5]=n,p[9]=h,p[13]=a,p[2]=o,p[6]=l,p[10]=u,p[14]=c,p[3]=m,p[7]=x,p[11]=d,p[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new h).fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/a.setFromMatrixColumn(t,0).length(),r=1/a.setFromMatrixColumn(t,1).length(),n=1/a.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*r,s[5]=e[5]*r,s[6]=e[6]*r,s[7]=0,s[8]=e[8]*n,s[9]=e[9]*n,s[10]=e[10]*n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){!t||t.isEuler;const s=this.elements,e=t.x,i=t.y,r=t.z,n=Math.cos(e),h=Math.sin(e),a=Math.cos(i),o=Math.sin(i),l=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=n*l,e=n*u,i=h*l,r=h*u;s[0]=a*l,s[4]=-a*u,s[8]=o,s[1]=e+i*o,s[5]=t-r*o,s[9]=-h*a,s[2]=r-t*o,s[6]=i+e*o,s[10]=n*a}else if("YXZ"===t.order){const t=a*l,e=a*u,i=o*l,r=o*u;s[0]=t+r*h,s[4]=i*h-e,s[8]=n*o,s[1]=n*u,s[5]=n*l,s[9]=-h,s[2]=e*h-i,s[6]=r+t*h,s[10]=n*a}else if("ZXY"===t.order){const t=a*l,e=a*u,i=o*l,r=o*u;s[0]=t-r*h,s[4]=-n*u,s[8]=i+e*h,s[1]=e+i*h,s[5]=n*l,s[9]=r-t*h,s[2]=-n*o,s[6]=h,s[10]=n*a}else if("ZYX"===t.order){const t=n*l,e=n*u,i=h*l,r=h*u;s[0]=a*l,s[4]=i*o-e,s[8]=t*o+r,s[1]=a*u,s[5]=r*o+t,s[9]=e*o-i,s[2]=-o,s[6]=h*a,s[10]=n*a}else if("YZX"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=r-t*u,s[8]=i*u+e,s[1]=u,s[5]=n*l,s[9]=-h*l,s[2]=-o*l,s[6]=e*u+i,s[10]=t-r*u}else if("XZY"===t.order){const t=n*a,e=n*o,i=h*a,r=h*o;s[0]=a*l,s[4]=-u,s[8]=o*l,s[1]=t*u+r,s[5]=n*l,s[9]=e*u-i,s[2]=i*u-e,s[6]=h*l,s[10]=r*u+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(l,t,u)}lookAt(t,s,e){const i=this.elements;return x.subVectors(t,s),0===x.lengthSq()&&(x.z=1),x.normalize(),c.crossVectors(e,x),0===c.lengthSq()&&(1===Math.abs(e.z)?x.x+=1e-4:x.z+=1e-4,x.normalize(),c.crossVectors(e,x)),c.normalize(),m.crossVectors(x,c),i[0]=c.x,i[4]=m.x,i[8]=x.x,i[1]=c.y,i[5]=m.y,i[9]=x.y,i[2]=c.z,i[6]=m.z,i[10]=x.z,this}multiply(t,s){return void 0!==s?this.multiplyMatrices(t,s):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,r=this.elements,n=e[0],h=e[4],a=e[8],o=e[12],l=e[1],u=e[5],c=e[9],m=e[13],x=e[2],d=e[6],y=e[10],p=e[14],M=e[3],z=e[7],f=e[11],g=e[15],_=i[0],b=i[4],v=i[8],w=i[12],A=i[1],C=i[5],O=i[9],F=i[13],S=i[2],k=i[6],W=i[10],q=i[14],j=i[3],V=i[7],Z=i[11],X=i[15];return r[0]=n*_+h*A+a*S+o*j,r[4]=n*b+h*C+a*k+o*V,r[8]=n*v+h*O+a*W+o*Z,r[12]=n*w+h*F+a*q+o*X,r[1]=l*_+u*A+c*S+m*j,r[5]=l*b+u*C+c*k+m*V,r[9]=l*v+u*O+c*W+m*Z,r[13]=l*w+u*F+c*q+m*X,r[2]=x*_+d*A+y*S+p*j,r[6]=x*b+d*C+y*k+p*V,r[10]=x*v+d*O+y*W+p*Z,r[14]=x*w+d*F+y*q+p*X,r[3]=M*_+z*A+f*S+g*j,r[7]=M*b+z*C+f*k+g*V,r[11]=M*v+z*O+f*W+g*Z,r[15]=M*w+z*F+f*q+g*X,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],r=t[12],n=t[1],h=t[5],a=t[9],o=t[13],l=t[2],u=t[6],c=t[10],m=t[14];return t[3]*(+r*a*u-i*o*u-r*h*c+e*o*c+i*h*m-e*a*m)+t[7]*(+s*a*m-s*o*c+r*n*c-i*n*m+i*o*l-r*a*l)+t[11]*(+s*o*u-s*h*m-r*n*u+e*n*m+r*h*l-e*o*l)+t[15]*(-i*h*l-s*a*u+s*h*c+i*n*u-e*n*c+e*a*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}getInverse(t,s){const e=this.elements,i=t.elements,r=i[0],n=i[1],h=i[2],a=i[3],o=i[4],l=i[5],u=i[6],c=i[7],m=i[8],x=i[9],d=i[10],y=i[11],p=i[12],M=i[13],z=i[14],f=i[15],g=x*z*c-M*d*c+M*u*y-l*z*y-x*u*f+l*d*f,_=p*d*c-m*z*c-p*u*y+o*z*y+m*u*f-o*d*f,b=m*M*c-p*x*c+p*l*y-o*M*y-m*l*f+o*x*f,v=p*x*u-m*M*u-p*l*d+o*M*d+m*l*z-o*x*z,w=r*g+n*_+h*b+a*v;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const A=1/w;return e[0]=g*A,e[1]=(M*d*a-x*z*a-M*h*y+n*z*y+x*h*f-n*d*f)*A,e[2]=(l*z*a-M*u*a+M*h*c-n*z*c-l*h*f+n*u*f)*A,e[3]=(x*u*a-l*d*a-x*h*c+n*d*c+l*h*y-n*u*y)*A,e[4]=_*A,e[5]=(m*z*a-p*d*a+p*h*y-r*z*y-m*h*f+r*d*f)*A,e[6]=(p*u*a-o*z*a-p*h*c+r*z*c+o*h*f-r*u*f)*A,e[7]=(o*d*a-m*u*a+m*h*c-r*d*c-o*h*y+r*u*y)*A,e[8]=b*A,e[9]=(p*x*a-m*M*a-p*n*y+r*M*y+m*n*f-r*x*f)*A,e[10]=(o*M*a-p*l*a+p*n*c-r*M*c-o*n*f+r*l*f)*A,e[11]=(m*l*a-o*x*a-m*n*c+r*x*c+o*n*y-r*l*y)*A,e[12]=v*A,e[13]=(m*M*h-p*x*h+p*n*d-r*M*d-m*n*z+r*x*z)*A,e[14]=(p*l*h-o*M*h-p*n*u+r*M*u+o*n*z-r*l*z)*A,e[15]=(o*x*h-m*l*h+m*n*u-r*x*u-o*n*d+r*l*d)*A,this}scale(t){const s=this.elements,e=t.x,i=t.y,r=t.z;return s[0]*=e,s[4]*=i,s[8]*=r,s[1]*=e,s[5]*=i,s[9]*=r,s[2]*=e,s[6]*=i,s[10]*=r,s[3]*=e,s[7]*=i,s[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),r=1-e,n=t.x,h=t.y,a=t.z,o=r*n,l=r*h;return this.set(o*n+e,o*h-i*a,o*a+i*h,0,o*h+i*a,l*h+e,l*a-i*n,0,o*a-i*h,l*a+i*n,r*a*a+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e){return this.set(1,s,e,0,t,1,e,0,t,s,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,r=s._x,n=s._y,h=s._z,a=s._w,o=r+r,l=n+n,u=h+h,c=r*o,m=r*l,x=r*u,d=n*l,y=n*u,p=h*u,M=a*o,z=a*l,f=a*u,g=e.x,_=e.y,b=e.z;return i[0]=(1-(d+p))*g,i[1]=(m+f)*g,i[2]=(x-z)*g,i[3]=0,i[4]=(m-f)*_,i[5]=(1-(c+p))*_,i[6]=(y+M)*_,i[7]=0,i[8]=(x+z)*b,i[9]=(y-M)*b,i[10]=(1-(c+d))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let r=a.set(i[0],i[1],i[2]).length();const n=a.set(i[4],i[5],i[6]).length(),h=a.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],o.copy(this);const l=1/r,u=1/n,c=1/h;return o.elements[0]*=l,o.elements[1]*=l,o.elements[2]*=l,o.elements[4]*=u,o.elements[5]*=u,o.elements[6]*=u,o.elements[8]*=c,o.elements[9]*=c,o.elements[10]*=c,s.setFromRotationMatrix(o),e.x=r,e.y=n,e.z=h,this}makePerspective(t,s,e,i,r,n){const h=this.elements,a=2*r/(s-t),o=2*r/(e-i),l=(s+t)/(s-t),u=(e+i)/(e-i),c=-(n+r)/(n-r),m=-2*n*r/(n-r);return h[0]=a,h[4]=0,h[8]=l,h[12]=0,h[1]=0,h[5]=o,h[9]=u,h[13]=0,h[2]=0,h[6]=0,h[10]=c,h[14]=m,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,s,e,i,r,n){const h=this.elements,a=1/(s-t),o=1/(e-i),l=1/(n-r),u=(s+t)*a,c=(e+i)*o,m=(n+r)*l;return h[0]=2*a,h[4]=0,h[8]=0,h[12]=-u,h[1]=0,h[5]=2*o,h[9]=0,h[13]=-c,h[2]=0,h[6]=0,h[10]=-2*l,h[14]=-m,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let t=0;t<16;t++)if(s[t]!==e[t])return!1;return!0}fromArray(t,s){void 0===s&&(s=0);for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(t,s){void 0===t&&(t=[]),void 0===s&&(s=0);const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}const a=new i,o=new h,l=new i(0,0,0),u=new i(1,1,1),c=new i,m=new i,x=new i;class d{constructor(t=0,s=0,e=0,i=d.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=t,this._y=s,this._z=e,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(s,e,i){const r=t.clamp,n=s.elements,h=n[0],a=n[4],o=n[8],l=n[1],u=n[5],c=n[9],m=n[2],x=n[6],d=n[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(r(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-a,h)):(this._x=Math.atan2(x,u),this._z=0);break;case"YXZ":this._x=Math.asin(-r(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-m,h),this._z=0);break;case"ZXY":this._x=Math.asin(r(x,-1,1)),Math.abs(x)<.9999999?(this._y=Math.atan2(-m,d),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(l,h));break;case"ZYX":this._y=Math.asin(-r(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(x,d),this._z=Math.atan2(l,h)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-m,h)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(x,u),this._y=Math.atan2(o,h)):(this._x=Math.atan2(-c,d),this._y=0)}return this._order=e,!1!==i&&this._onChangeCallback(),this}setFromQuaternion(t,s,e){return y.makeRotationFromQuaternion(t),this.setFromRotationMatrix(y,s,e)}setFromVector3(t,s){return this.set(t.x,t.y,t.z,s||this._order)}reorder(t){return p.setFromEuler(this),this.setFromQuaternion(p,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t,s){return void 0===t&&(t=[]),void 0===s&&(s=0),t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new i(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}d.DefaultOrder="XYZ",d.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const y=new h,p=new e;class M{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}class z{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1]}set(t,s,e,i,r,n,h,a,o){const l=this.elements;return l[0]=t,l[1]=i,l[2]=h,l[3]=s,l[4]=r,l[5]=a,l[6]=e,l[7]=n,l[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],this}extractBasis(t,s,e){return t.setFromMatrix3Column(this,0),s.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const s=t.elements;return this.set(s[0],s[4],s[8],s[1],s[5],s[9],s[2],s[6],s[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,r=this.elements,n=e[0],h=e[3],a=e[6],o=e[1],l=e[4],u=e[7],c=e[2],m=e[5],x=e[8],d=i[0],y=i[3],p=i[6],M=i[1],z=i[4],f=i[7],g=i[2],_=i[5],b=i[8];return r[0]=n*d+h*M+a*g,r[3]=n*y+h*z+a*_,r[6]=n*p+h*f+a*b,r[1]=o*d+l*M+u*g,r[4]=o*y+l*z+u*_,r[7]=o*p+l*f+u*b,r[2]=c*d+m*M+x*g,r[5]=c*y+m*z+x*_,r[8]=c*p+m*f+x*b,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[3]*=t,s[6]*=t,s[1]*=t,s[4]*=t,s[7]*=t,s[2]*=t,s[5]*=t,s[8]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[1],i=t[2],r=t[3],n=t[4],h=t[5],a=t[6],o=t[7],l=t[8];return s*n*l-s*h*o-e*r*l+e*h*a+i*r*o-i*n*a}getInverse(t,s){const e=t.elements,i=this.elements,r=e[0],n=e[1],h=e[2],a=e[3],o=e[4],l=e[5],u=e[6],c=e[7],m=e[8],x=m*o-l*c,d=l*u-m*a,y=c*a-o*u,p=r*x+n*d+h*y;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const M=1/p;return i[0]=x*M,i[1]=(h*c-m*n)*M,i[2]=(l*n-h*o)*M,i[3]=d*M,i[4]=(m*r-h*u)*M,i[5]=(h*a-l*r)*M,i[6]=y*M,i[7]=(n*u-c*r)*M,i[8]=(o*r-n*a)*M,this}transpose(){let t;const s=this.elements;return t=s[1],s[1]=s[3],s[3]=t,t=s[2],s[2]=s[6],s[6]=t,t=s[5],s[5]=s[7],s[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).getInverse(this).transpose()}transposeIntoArray(t){const s=this.elements;return t[0]=s[0],t[1]=s[3],t[2]=s[6],t[3]=s[1],t[4]=s[4],t[5]=s[7],t[6]=s[2],t[7]=s[5],t[8]=s[8],this}setUvTransform(t,s,e,i,r,n,h){const a=Math.cos(r),o=Math.sin(r);this.set(e*a,e*o,-e*(a*n+o*h)+n+t,-i*o,i*a,-i*(-o*n+a*h)+h+s,0,0,1)}scale(t,s){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=s,e[4]*=s,e[7]*=s,this}rotate(t){const s=Math.cos(t),e=Math.sin(t),i=this.elements,r=i[0],n=i[3],h=i[6],a=i[1],o=i[4],l=i[7];return i[0]=s*r+e*a,i[3]=s*n+e*o,i[6]=s*h+e*l,i[1]=-e*r+s*a,i[4]=-e*n+s*o,i[7]=-e*h+s*l,this}translate(t,s){const e=this.elements;return e[0]+=t*e[2],e[3]+=t*e[5],e[6]+=t*e[8],e[1]+=s*e[2],e[4]+=s*e[5],e[7]+=s*e[8],this}equals(t){const s=this.elements,e=t.elements;for(let t=0;t<9;t++)if(s[t]!==e[t])return!1;return!0}fromArray(t,s){void 0===s&&(s=0);for(let e=0;e<9;e++)this.elements[e]=t[e+s];return this}toArray(t,s){void 0===t&&(t=[]),void 0===s&&(s=0);const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t}}let f=0;const g=new i,_=new e,b=new h,v=new i,w=new i,A=new i,C=new e,O=new i(1,0,0),F=new i(0,1,0),S=new i(0,0,1),k={type:"added"},W={type:"removed"};function q(){Object.defineProperty(this,"id",{value:f++}),this.uuid=t.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=q.DefaultUp.clone();const s=new i,r=new d,n=new e,a=new i(1,1,1);r._onChange((function(){n.setFromEuler(r,!1)})),n._onChange((function(){r.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:s},rotation:{configurable:!0,enumerable:!0,value:r},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new h},normalMatrix:{value:new z}}),this.matrix=new h,this.matrixWorld=new h,this.matrixAutoUpdate=q.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new M,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}q.DefaultUp=new i(0,1,0),q.DefaultMatrixAutoUpdate=!0,q.prototype=Object.assign(Object.create(s.prototype),{constructor:q,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,s){this.quaternion.setFromAxisAngle(t,s)},setRotationFromEuler:function(t){this.quaternion.setFromEuler(t,!0)},setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:function(t,s){return _.setFromAxisAngle(t,s),this.quaternion.multiply(_),this},rotateOnWorldAxis:function(t,s){return _.setFromAxisAngle(t,s),this.quaternion.premultiply(_),this},rotateX:function(t){return this.rotateOnAxis(O,t)},rotateY:function(t){return this.rotateOnAxis(F,t)},rotateZ:function(t){return this.rotateOnAxis(S,t)},translateOnAxis:function(t,s){return g.copy(t).applyQuaternion(this.quaternion),this.position.add(g.multiplyScalar(s)),this},translateX:function(t){return this.translateOnAxis(O,t)},translateY:function(t){return this.translateOnAxis(F,t)},translateZ:function(t){return this.translateOnAxis(S,t)},localToWorld:function(t){return t.applyMatrix4(this.matrixWorld)},worldToLocal:function(t){return t.applyMatrix4(b.getInverse(this.matrixWorld))},lookAt:function(t,s,e){t.isVector3?v.copy(t):v.set(t,s,e);const i=this.parent;this.updateWorldMatrix(!0,!1),w.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?b.lookAt(w,v,this.up):b.lookAt(v,w,this.up),this.quaternion.setFromRotationMatrix(b),i&&(b.extractRotation(i.matrixWorld),_.setFromRotationMatrix(b),this.quaternion.premultiply(_.inverse()))},add:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this||t&&t.isObject3D&&(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(k)),this},remove:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const s=this.children.indexOf(t);return-1!==s&&(t.parent=null,this.children.splice(s,1),t.dispatchEvent(W)),this},attach:function(t){return this.updateWorldMatrix(!0,!1),b.getInverse(this.matrixWorld),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),b.multiply(t.parent.matrixWorld)),t.applyMatrix4(b),t.updateWorldMatrix(!1,!1),this.add(t),this},getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:function(t){return this.getObjectByProperty("name",t)},getObjectByProperty:function(t,s){if(this[t]===s)return this;for(let e=0,i=this.children.length;e<i;e++){const i=this.children[e].getObjectByProperty(t,s);if(void 0!==i)return i}},getWorldPosition:function(t){return void 0===t&&(t=new i),this.updateMatrixWorld(!0),t.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(t){return void 0===t&&(t=new e),this.updateMatrixWorld(!0),this.matrixWorld.decompose(w,t,A),t},getWorldScale:function(t){return void 0===t&&(t=new i),this.updateMatrixWorld(!0),this.matrixWorld.decompose(w,C,t),t},getWorldDirection:function(t){void 0===t&&(t=new i),this.updateMatrixWorld(!0);const s=this.matrixWorld.elements;return t.set(s[8],s[9],s[10]).normalize()},raycast:function(){},traverse:function(t){t(this);const s=this.children;for(let e=0,i=s.length;e<i;e++)s[e].traverse(t)},traverseVisible:function(t){if(!1===this.visible)return;t(this);const s=this.children;for(let e=0,i=s.length;e<i;e++)s[e].traverseVisible(t)},traverseAncestors:function(t){const s=this.parent;null!==s&&(t(s),s.traverseAncestors(t))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const s=this.children;for(let e=0,i=s.length;e<i;e++)s[e].updateMatrixWorld(t)},updateWorldMatrix:function(t,s){const e=this.parent;if(!0===t&&null!==e&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===s){const t=this.children;for(let s=0,e=t.length;s<e;s++)t[s].updateWorldMatrix(!1,!0)}},toJSON:function(t){const s=void 0===t||"string"==typeof t,e={};s&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(s,e){return void 0===s[e.uuid]&&(s[e.uuid]=e.toJSON(t)),e.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const s=this.geometry.parameters;if(void 0!==s&&void 0!==s.shapes){const e=s.shapes;if(Array.isArray(e))for(let s=0,i=e.length;s<i;s++){const i=e[s];r(t.shapes,i)}else r(t.shapes,e)}}if(void 0!==this.material)if(Array.isArray(this.material)){const s=[];for(let e=0,i=this.material.length;e<i;e++)s.push(r(t.materials,this.material[e]));i.material=s}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let s=0;s<this.children.length;s++)i.children.push(this.children[s].toJSON(t).object)}if(s){const s=n(t.geometries),i=n(t.materials),r=n(t.textures),h=n(t.images),a=n(t.shapes);s.length>0&&(e.geometries=s),i.length>0&&(e.materials=i),r.length>0&&(e.textures=r),h.length>0&&(e.images=h),a.length>0&&(e.shapes=a)}return e.object=i,e;function n(t){const s=[];for(const e in t){const i=t[e];delete i.metadata,s.push(i)}return s}},clone:function(t){return(new this.constructor).copy(this,t)},copy:function(t,s){if(void 0===s&&(s=!0),this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===s)for(let s=0;s<t.children.length;s++){const e=t.children[s];this.add(e.clone())}return this}});export{M as L,h as M,q as O,i as V,z as a};
//# sourceMappingURL=Object3D.js.map
