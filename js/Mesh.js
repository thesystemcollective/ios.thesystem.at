import{B as t,D as n}from"./constants.js";import{a as i}from"./MeshBasicMaterial.js";import{V as e,a as o,O as r,M as s}from"./Object3D.js";import{V as c,e as a,S as u,B as h}from"./BufferGeometry.js";const l=new e,d=new e,f=new e,m=new e,p=new e,y=new e,g=new e;function b(t,n){this.origin=void 0!==t?t:new e,this.direction=void 0!==n?n:new e(0,0,-1)}Object.assign(b.prototype,{set:function(t,n){return this.origin.copy(t),this.direction.copy(n),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this},at:function(t,n){return void 0===n&&(n=new e),n.copy(this.direction).multiplyScalar(t).add(this.origin)},lookAt:function(t){return this.direction.copy(t).sub(this.origin).normalize(),this},recast:function(t){return this.origin.copy(this.at(t,l)),this},closestPointToPoint:function(t,n){void 0===n&&(n=new e),n.subVectors(t,this.origin);const i=n.dot(this.direction);return i<0?n.copy(this.origin):n.copy(this.direction).multiplyScalar(i).add(this.origin)},distanceToPoint:function(t){return Math.sqrt(this.distanceSqToPoint(t))},distanceSqToPoint:function(t){const n=l.subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):(l.copy(this.direction).multiplyScalar(n).add(this.origin),l.distanceToSquared(t))},distanceSqToSegment:function(t,n,i,e){d.copy(t).add(n).multiplyScalar(.5),f.copy(n).sub(t).normalize(),m.copy(this.origin).sub(d);const o=.5*t.distanceTo(n),r=-this.direction.dot(f),s=m.dot(this.direction),c=-m.dot(f),a=m.lengthSq(),u=Math.abs(1-r*r);let h,l,p,y;if(u>0)if(h=r*c-s,l=r*s-c,y=o*u,h>=0)if(l>=-y)if(l<=y){const t=1/u;h*=t,l*=t,p=h*(h+r*l+2*s)+l*(r*h+l+2*c)+a}else l=o,h=Math.max(0,-(r*l+s)),p=-h*h+l*(l+2*c)+a;else l=-o,h=Math.max(0,-(r*l+s)),p=-h*h+l*(l+2*c)+a;else l<=-y?(h=Math.max(0,-(-r*o+s)),l=h>0?-o:Math.min(Math.max(-o,-c),o),p=-h*h+l*(l+2*c)+a):l<=y?(h=0,l=Math.min(Math.max(-o,-c),o),p=l*(l+2*c)+a):(h=Math.max(0,-(r*o+s)),l=h>0?o:Math.min(Math.max(-o,-c),o),p=-h*h+l*(l+2*c)+a);else l=r>0?-o:o,h=Math.max(0,-(r*l+s)),p=-h*h+l*(l+2*c)+a;return i&&i.copy(this.direction).multiplyScalar(h).add(this.origin),e&&e.copy(f).multiplyScalar(l).add(d),p},intersectSphere:function(t,n){l.subVectors(t.center,this.origin);const i=l.dot(this.direction),e=l.dot(l)-i*i,o=t.radius*t.radius;if(e>o)return null;const r=Math.sqrt(o-e),s=i-r,c=i+r;return s<0&&c<0?null:s<0?this.at(c,n):this.at(s,n)},intersectsSphere:function(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius},distanceToPlane:function(t){const n=t.normal.dot(this.direction);if(0===n)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/n;return i>=0?i:null},intersectPlane:function(t,n){const i=this.distanceToPlane(t);return null===i?null:this.at(i,n)},intersectsPlane:function(t){const n=t.distanceToPoint(this.origin);if(0===n)return!0;return t.normal.dot(this.direction)*n<0},intersectBox:function(t,n){let i,e,o,r,s,c;const a=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,l=this.origin;return a>=0?(i=(t.min.x-l.x)*a,e=(t.max.x-l.x)*a):(i=(t.max.x-l.x)*a,e=(t.min.x-l.x)*a),u>=0?(o=(t.min.y-l.y)*u,r=(t.max.y-l.y)*u):(o=(t.max.y-l.y)*u,r=(t.min.y-l.y)*u),i>r||o>e?null:((o>i||i!=i)&&(i=o),(r<e||e!=e)&&(e=r),h>=0?(s=(t.min.z-l.z)*h,c=(t.max.z-l.z)*h):(s=(t.max.z-l.z)*h,c=(t.min.z-l.z)*h),i>c||s>e?null:((s>i||i!=i)&&(i=s),(c<e||e!=e)&&(e=c),e<0?null:this.at(i>=0?i:e,n)))},intersectsBox:function(t){return null!==this.intersectBox(t,l)},intersectTriangle:function(t,n,i,e,o){p.subVectors(n,t),y.subVectors(i,t),g.crossVectors(p,y);let r,s=this.direction.dot(g);if(s>0){if(e)return null;r=1}else{if(!(s<0))return null;r=-1,s=-s}m.subVectors(this.origin,t);const c=r*this.direction.dot(y.crossVectors(m,y));if(c<0)return null;const a=r*this.direction.dot(p.cross(m));if(a<0)return null;if(c+a>s)return null;const u=-r*m.dot(g);return u<0?null:this.at(u/s,o)},applyMatrix4:function(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this},equals:function(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}});const x=new e,w=new e,V=new o;function M(t,n){this.normal=void 0!==t?t:new e(1,0,0),this.constant=void 0!==n?n:0}Object.assign(M.prototype,{isPlane:!0,set:function(t,n){return this.normal.copy(t),this.constant=n,this},setComponents:function(t,n,i,e){return this.normal.set(t,n,i),this.constant=e,this},setFromNormalAndCoplanarPoint:function(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this},setFromCoplanarPoints:function(t,n,i){const e=x.subVectors(i,n).cross(w.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(e,t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this},normalize:function(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(t){return this.normal.dot(t)+this.constant},distanceToSphere:function(t){return this.distanceToPoint(t.center)-t.radius},projectPoint:function(t,n){return void 0===n&&(n=new e),n.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)},intersectLine:function(t,n){void 0===n&&(n=new e);const i=t.delta(x),o=this.normal.dot(i);if(0===o)return 0===this.distanceToPoint(t.start)?n.copy(t.start):void 0;const r=-(t.start.dot(this.normal)+this.constant)/o;return r<0||r>1?void 0:n.copy(i).multiplyScalar(r).add(t.start)},intersectsLine:function(t){const n=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return n<0&&i>0||i<0&&n>0},intersectsBox:function(t){return t.intersectsPlane(this)},intersectsSphere:function(t){return t.intersectsPlane(this)},coplanarPoint:function(t){return void 0===t&&(t=new e),t.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(t,n){const i=n||V.getNormalMatrix(t),e=this.coplanarPoint(x).applyMatrix4(t),o=this.normal.applyMatrix3(i).normalize();return this.constant=-e.dot(o),this},translate:function(t){return this.constant-=t.dot(this.normal),this},equals:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant}});const S=new e,T=new e,v=new e,P=new e,B=new e,A=new e,q=new e,I=new e,j=new e,z=new e;function F(t,n,i){this.a=void 0!==t?t:new e,this.b=void 0!==n?n:new e,this.c=void 0!==i?i:new e}Object.assign(F,{getNormal:function(t,n,i,o){void 0===o&&(o=new e),o.subVectors(i,n),S.subVectors(t,n),o.cross(S);const r=o.lengthSq();return r>0?o.multiplyScalar(1/Math.sqrt(r)):o.set(0,0,0)},getBarycoord:function(t,n,i,o,r){S.subVectors(o,n),T.subVectors(i,n),v.subVectors(t,n);const s=S.dot(S),c=S.dot(T),a=S.dot(v),u=T.dot(T),h=T.dot(v),l=s*u-c*c;if(void 0===r&&(r=new e),0===l)return r.set(-2,-1,-1);const d=1/l,f=(u*a-c*h)*d,m=(s*h-c*a)*d;return r.set(1-f-m,m,f)},containsPoint:function(t,n,i,e){return F.getBarycoord(t,n,i,e,P),P.x>=0&&P.y>=0&&P.x+P.y<=1},getUV:function(t,n,i,e,o,r,s,c){return this.getBarycoord(t,n,i,e,P),c.set(0,0),c.addScaledVector(o,P.x),c.addScaledVector(r,P.y),c.addScaledVector(s,P.z),c},isFrontFacing:function(t,n,i,e){return S.subVectors(i,n),T.subVectors(t,n),S.cross(T).dot(e)<0}}),Object.assign(F.prototype,{set:function(t,n,i){return this.a.copy(t),this.b.copy(n),this.c.copy(i),this},setFromPointsAndIndices:function(t,n,i,e){return this.a.copy(t[n]),this.b.copy(t[i]),this.c.copy(t[e]),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this},getArea:function(){return S.subVectors(this.c,this.b),T.subVectors(this.a,this.b),.5*S.cross(T).length()},getMidpoint:function(t){return void 0===t&&(t=new e),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(t){return F.getNormal(this.a,this.b,this.c,t)},getPlane:function(t){return void 0===t&&(t=new M),t.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(t,n){return F.getBarycoord(t,this.a,this.b,this.c,n)},getUV:function(t,n,i,e,o){return F.getUV(t,this.a,this.b,this.c,n,i,e,o)},containsPoint:function(t){return F.containsPoint(t,this.a,this.b,this.c)},isFrontFacing:function(t){return F.isFrontFacing(this.a,this.b,this.c,t)},intersectsBox:function(t){return t.intersectsTriangle(this)},closestPointToPoint:function(t,n){void 0===n&&(n=new e);const i=this.a,o=this.b,r=this.c;let s,c;B.subVectors(o,i),A.subVectors(r,i),I.subVectors(t,i);const a=B.dot(I),u=A.dot(I);if(a<=0&&u<=0)return n.copy(i);j.subVectors(t,o);const h=B.dot(j),l=A.dot(j);if(h>=0&&l<=h)return n.copy(o);const d=a*l-h*u;if(d<=0&&a>=0&&h<=0)return s=a/(a-h),n.copy(i).addScaledVector(B,s);z.subVectors(t,r);const f=B.dot(z),m=A.dot(z);if(m>=0&&f<=m)return n.copy(r);const p=f*u-a*m;if(p<=0&&u>=0&&m<=0)return c=u/(u-m),n.copy(i).addScaledVector(A,c);const y=h*m-f*l;if(y<=0&&l-h>=0&&f-m>=0)return q.subVectors(r,o),c=(l-h)/(l-h+(f-m)),n.copy(o).addScaledVector(q,c);const g=1/(y+p+d);return s=p*g,c=d*g,n.copy(i).addScaledVector(B,s).addScaledVector(A,c)},equals:function(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}});const O=new s,D=new b,N=new u,U=new e,X=new e,C=new e,G=new e,_=new e,k=new e,R=new e,L=new e,W=new e,E=new c,H=new c,J=new c,K=new e,Q=new e;function Y(t,n){r.call(this),this.type="Mesh",this.geometry=void 0!==t?t:new h,this.material=void 0!==n?n:new i,this.updateMorphTargets()}function Z(i,e,o,r,s,c,a,u){let h;if(h=e.side===t?r.intersectTriangle(a,c,s,!0,u):r.intersectTriangle(s,c,a,e.side!==n,u),null===h)return null;Q.copy(u),Q.applyMatrix4(i.matrixWorld);const l=o.ray.origin.distanceTo(Q);return l<o.near||l>o.far?null:{distance:l,point:Q.clone(),object:i}}function $(t,n,i,e,o,r,s,u,h,l,d,f){U.fromBufferAttribute(o,l),X.fromBufferAttribute(o,d),C.fromBufferAttribute(o,f);const m=t.morphTargetInfluences;if(n.morphTargets&&r&&m){R.set(0,0,0),L.set(0,0,0),W.set(0,0,0);for(let t=0,n=r.length;t<n;t++){const n=m[t],i=r[t];0!==n&&(G.fromBufferAttribute(i,l),_.fromBufferAttribute(i,d),k.fromBufferAttribute(i,f),s?(R.addScaledVector(G,n),L.addScaledVector(_,n),W.addScaledVector(k,n)):(R.addScaledVector(G.sub(U),n),L.addScaledVector(_.sub(X),n),W.addScaledVector(k.sub(C),n)))}U.add(R),X.add(L),C.add(W)}t.isSkinnedMesh&&(t.boneTransform(l,U),t.boneTransform(d,X),t.boneTransform(f,C));const p=Z(t,n,i,e,U,X,C,K);if(p){u&&(E.fromBufferAttribute(u,l),H.fromBufferAttribute(u,d),J.fromBufferAttribute(u,f),p.uv=F.getUV(K,U,X,C,E,H,J,new c)),h&&(E.fromBufferAttribute(h,l),H.fromBufferAttribute(h,d),J.fromBufferAttribute(h,f),p.uv2=F.getUV(K,U,X,C,E,H,J,new c));const t=new a(l,d,f);F.getNormal(U,X,C,t.normal),p.face=t}return p}Y.prototype=Object.assign(Object.create(r.prototype),{constructor:Y,isMesh:!0,copy:function(t){return r.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const n=t.morphAttributes,i=Object.keys(n);if(i.length>0){const t=n[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++){const i=t[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=n}}}}else{const n=t.morphTargets;void 0!==n&&n.length}},raycast:function(t,n){const i=this.geometry,e=this.material,o=this.matrixWorld;if(void 0===e)return;if(null===i.boundingSphere&&i.computeBoundingSphere(),N.copy(i.boundingSphere),N.applyMatrix4(o),!1===t.ray.intersectsSphere(N))return;if(O.getInverse(o),D.copy(t.ray).applyMatrix4(O),null!==i.boundingBox&&!1===D.intersectsBox(i.boundingBox))return;let r;if(i.isBufferGeometry){const o=i.index,s=i.attributes.position,c=i.morphAttributes.position,a=i.morphTargetsRelative,u=i.attributes.uv,h=i.attributes.uv2,l=i.groups,d=i.drawRange;if(null!==o)if(Array.isArray(e))for(let i=0,f=l.length;i<f;i++){const f=l[i],m=e[f.materialIndex];for(let i=Math.max(f.start,d.start),e=Math.min(f.start+f.count,d.start+d.count);i<e;i+=3){const e=o.getX(i),l=o.getX(i+1),d=o.getX(i+2);r=$(this,m,t,D,s,c,a,u,h,e,l,d),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=f.materialIndex,n.push(r))}}else{for(let i=Math.max(0,d.start),l=Math.min(o.count,d.start+d.count);i<l;i+=3){const l=o.getX(i),d=o.getX(i+1),f=o.getX(i+2);r=$(this,e,t,D,s,c,a,u,h,l,d,f),r&&(r.faceIndex=Math.floor(i/3),n.push(r))}}else if(void 0!==s)if(Array.isArray(e))for(let i=0,o=l.length;i<o;i++){const o=l[i],f=e[o.materialIndex];for(let i=Math.max(o.start,d.start),e=Math.min(o.start+o.count,d.start+d.count);i<e;i+=3){r=$(this,f,t,D,s,c,a,u,h,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=o.materialIndex,n.push(r))}}else{for(let i=Math.max(0,d.start),o=Math.min(s.count,d.start+d.count);i<o;i+=3){r=$(this,e,t,D,s,c,a,u,h,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),n.push(r))}}}else if(i.isGeometry){const o=Array.isArray(e),s=i.vertices,a=i.faces;let u;const h=i.faceVertexUvs[0];h.length>0&&(u=h);for(let i=0,h=a.length;i<h;i++){const h=a[i],l=o?e[h.materialIndex]:e;if(void 0===l)continue;const d=s[h.a],f=s[h.b],m=s[h.c];if(r=Z(this,l,t,D,d,f,m,K),r){if(u&&u[i]){const t=u[i];E.copy(t[0]),H.copy(t[1]),J.copy(t[2]),r.uv=F.getUV(K,d,f,m,E,H,J,new c)}r.face=h,r.faceIndex=i,n.push(r)}}}}});var tt=Object.freeze({__proto__:null,Mesh:Y});export{Y as M,M as P,b as R,tt as a};
//# sourceMappingURL=Mesh.js.map
