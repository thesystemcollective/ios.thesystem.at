{"version":3,"file":"Triangle.js","sources":["../../node_modules/three/src/math/Ray.js","../../node_modules/three/src/math/Plane.js","../../node_modules/three/src/math/Triangle.js"],"sourcesContent":["import { Vector3 } from './Vector3.js';\n\nconst _vector = new Vector3();\nconst _segCenter = new Vector3();\nconst _segDir = new Vector3();\nconst _diff = new Vector3();\n\nconst _edge1 = new Vector3();\nconst _edge2 = new Vector3();\nconst _normal = new Vector3();\n\nclass Ray {\n\n\tconstructor( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n}\n\n\nexport { Ray };\n","import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = new Vector3();\nconst _vector2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal, constant ) {\n\n\t\tObject.defineProperty( this, 'isPlane', { value: true } );\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n}\n\n\nexport { Plane };\n","import { Vector3 } from './Vector3.js';\nimport { Plane } from './Plane.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _v3 = new Vector3();\n\nconst _vab = new Vector3();\nconst _vac = new Vector3();\nconst _vbc = new Vector3();\nconst _vap = new Vector3();\nconst _vbp = new Vector3();\nconst _vcp = new Vector3();\n\nclass Triangle {\n\n\tconstructor( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0.subVectors( a, b );\n\t\ttarget.cross( _v0 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0.subVectors( c, a );\n\t\t_v1.subVectors( b, a );\n\t\t_v2.subVectors( point, a );\n\n\t\tconst dot00 = _v0.dot( _v0 );\n\t\tconst dot01 = _v0.dot( _v1 );\n\t\tconst dot02 = _v0.dot( _v2 );\n\t\tconst dot11 = _v1.dot( _v1 );\n\t\tconst dot12 = _v1.dot( _v2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\tthis.getBarycoord( point, a, b, c, _v3 );\n\n\t\treturn ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );\n\n\t}\n\n\tstatic getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3 );\n\n\t\ttarget.set( 0, 0 );\n\t\ttarget.addScaledVector( uv1, _v3.x );\n\t\ttarget.addScaledVector( uv2, _v3.y );\n\t\ttarget.addScaledVector( uv3, _v3.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0.subVectors( c, b );\n\t\t_v1.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0.subVectors( this.c, this.b );\n\t\t_v1.subVectors( this.a, this.b );\n\n\t\treturn _v0.cross( _v1 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Plane();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetUV( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\n\nexport { Triangle };\n"],"names":["_vector","Vector3","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","[object Object]","origin","direction","this","undefined","copy","constructor","ray","t","target","multiplyScalar","add","v","sub","normalize","at","point","subVectors","directionDistance","dot","Math","sqrt","distanceSqToPoint","distanceToSquared","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","sphere","center","tca","d2","radius2","radius","thc","t0","t1","plane","denominator","normal","distanceToPoint","constant","distanceToPlane","distToPoint","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","intersectBox","a","b","backfaceCulling","crossVectors","sign","DdN","DdQxE2","DdE1xQ","cross","QdN","matrix4","applyMatrix4","transformDirection","equals","_vector1","_vector2","_normalMatrix","Matrix3","Plane","Object","defineProperty","value","w","set","setFromNormalAndCoplanarPoint","inverseNormalLength","length","negate","line","delta","start","startSign","endSign","end","intersectsPlane","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","coplanarPoint","applyMatrix3","offset","_v0","_v1","_v2","_v3","_vab","_vac","_vbc","_vap","_vbp","_vcp","Triangle","targetLengthSq","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","getBarycoord","p1","p2","p3","uv1","uv2","uv3","addScaledVector","points","i0","i1","i2","triangle","addVectors","getNormal","setFromCoplanarPoints","getUV","containsPoint","isFrontFacing","intersectsTriangle","p","d1","d3","d4","vc","d5","d6","vb","va"],"mappings":"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"}