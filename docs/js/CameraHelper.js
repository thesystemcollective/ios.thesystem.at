import{O as t,V as e,M as i,a as n,C as r,R as o,S as s,F as c,B as a}from"./BufferGeometry.js";function p(){t.call(this),this.type="Camera",this.matrixWorldInverse=new i,this.projectionMatrix=new i,this.projectionMatrixInverse=new i}function l(t){n.call(this),this.type="LineBasicMaterial",this.color=new r(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}p.prototype=Object.assign(Object.create(t.prototype),{constructor:p,isCamera:!0,copy:function(e,i){return t.prototype.copy.call(this,e,i),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(t){void 0===t&&(t=new e),this.updateMatrixWorld(!0);const i=this.matrixWorld.elements;return t.set(-i[8],-i[9],-i[10]).normalize()},updateMatrixWorld:function(e){t.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.getInverse(this.matrixWorld)},updateWorldMatrix:function(e,i){t.prototype.updateWorldMatrix.call(this,e,i),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}}),l.prototype=Object.create(n.prototype),l.prototype.constructor=l,l.prototype.isLineBasicMaterial=!0,l.prototype.copy=function(t){return n.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this};const h=new e,u=new e,f=new i,y=new o,d=new s;function m(e,i,n){t.call(this),this.type="Line",this.geometry=void 0!==e?e:new a,this.material=void 0!==i?i:new l,this.updateMorphTargets()}m.prototype=Object.assign(Object.create(t.prototype),{constructor:m,isLine:!0,copy:function(e){return t.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry){if(null===t.index){const e=t.attributes.position,i=[0];for(let t=1,n=e.count;t<n;t++)h.fromBufferAttribute(e,t-1),u.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=h.distanceTo(u);t.setAttribute("lineDistance",new c(i,1))}}else if(t.isGeometry){const e=t.vertices,i=t.lineDistances;i[0]=0;for(let t=1,n=e.length;t<n;t++)i[t]=i[t-1],i[t]+=e[t-1].distanceTo(e[t])}return this},raycast:function(t,i){const n=this.geometry,r=this.matrixWorld,o=t.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),d.copy(n.boundingSphere),d.applyMatrix4(r),d.radius+=o,!1===t.ray.intersectsSphere(d))return;f.getInverse(r),y.copy(t.ray).applyMatrix4(f);const s=o/((this.scale.x+this.scale.y+this.scale.z)/3),c=s*s,a=new e,p=new e,l=new e,h=new e,u=this&&this.isLineSegments?2:1;if(n.isBufferGeometry){const e=n.index,r=n.attributes.position.array;if(null!==e){const n=e.array;for(let e=0,o=n.length-1;e<o;e+=u){const o=n[e],s=n[e+1];a.fromArray(r,3*o),p.fromArray(r,3*s);if(y.distanceSqToSegment(a,p,h,l)>c)continue;h.applyMatrix4(this.matrixWorld);const u=t.ray.origin.distanceTo(h);u<t.near||u>t.far||i.push({distance:u,point:l.clone().applyMatrix4(this.matrixWorld),index:e,face:null,faceIndex:null,object:this})}}else for(let e=0,n=r.length/3-1;e<n;e+=u){a.fromArray(r,3*e),p.fromArray(r,3*e+3);if(y.distanceSqToSegment(a,p,h,l)>c)continue;h.applyMatrix4(this.matrixWorld);const n=t.ray.origin.distanceTo(h);n<t.near||n>t.far||i.push({distance:n,point:l.clone().applyMatrix4(this.matrixWorld),index:e,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const e=n.vertices,r=e.length;for(let n=0;n<r-1;n+=u){if(y.distanceSqToSegment(e[n],e[n+1],h,l)>c)continue;h.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(h);r<t.near||r>t.far||i.push({distance:r,point:l.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){const i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length}}});const x=new e,g=new e;function w(t,e){m.call(this,t,e),this.type="LineSegments"}w.prototype=Object.assign(Object.create(m.prototype),{constructor:w,isLineSegments:!0,computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry){if(null===t.index){const e=t.attributes.position,i=[];for(let t=0,n=e.count;t<n;t+=2)x.fromBufferAttribute(e,t),g.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+x.distanceTo(g);t.setAttribute("lineDistance",new c(i,1))}}else if(t.isGeometry){const e=t.vertices,i=t.lineDistances;for(let t=0,n=e.length;t<n;t+=2)x.copy(e[t]),g.copy(e[t+1]),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+x.distanceTo(g)}return this}});const M=new e,b=new p;class j extends w{constructor(t){const e=new a,i=new l({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],o=[],s={},p=new r(16755200),h=new r(16711680),u=new r(43775),f=new r(16777215),y=new r(3355443);function d(t,e,i){m(t,i),m(e,i)}function m(t,e){n.push(0,0,0),o.push(e.r,e.g,e.b),void 0===s[t]&&(s[t]=[]),s[t].push(n.length/3-1)}d("n1","n2",p),d("n2","n4",p),d("n4","n3",p),d("n3","n1",p),d("f1","f2",p),d("f2","f4",p),d("f4","f3",p),d("f3","f1",p),d("n1","f1",p),d("n2","f2",p),d("n3","f3",p),d("n4","f4",p),d("p","n1",h),d("p","n2",h),d("p","n3",h),d("p","n4",h),d("u1","u2",u),d("u2","u3",u),d("u3","u1",u),d("c","t",f),d("p","c",y),d("cn1","cn2",y),d("cn3","cn4",y),d("cf1","cf2",y),d("cf3","cf4",y),e.setAttribute("position",new c(n,3)),e.setAttribute("color",new c(o,3)),super(e,i),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const t=this.geometry,e=this.pointMap;b.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),v("c",e,t,b,0,0,-1),v("t",e,t,b,0,0,1),v("n1",e,t,b,-1,-1,-1),v("n2",e,t,b,1,-1,-1),v("n3",e,t,b,-1,1,-1),v("n4",e,t,b,1,1,-1),v("f1",e,t,b,-1,-1,1),v("f2",e,t,b,1,-1,1),v("f3",e,t,b,-1,1,1),v("f4",e,t,b,1,1,1),v("u1",e,t,b,.7,1.1,-1),v("u2",e,t,b,-.7,1.1,-1),v("u3",e,t,b,0,2,-1),v("cf1",e,t,b,-1,0,1),v("cf2",e,t,b,1,0,1),v("cf3",e,t,b,0,-1,1),v("cf4",e,t,b,0,1,1),v("cn1",e,t,b,-1,0,-1),v("cn2",e,t,b,1,0,-1),v("cn3",e,t,b,0,-1,-1),v("cn4",e,t,b,0,1,-1),t.getAttribute("position").needsUpdate=!0}}function v(t,e,i,n,r,o,s){M.set(r,o,s).unproject(n);const c=e[t];if(void 0!==c){const t=i.getAttribute("position");for(let e=0,i=c.length;e<i;e++)t.setXYZ(c[e],M.x,M.y,M.z)}}export{j as CameraHelper};
