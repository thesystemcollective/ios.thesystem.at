{"version":3,"file":"RingGeometry.js","sources":["../../node_modules/three/src/geometries/RingGeometry.js"],"sourcesContent":["import { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n// RingGeometry\n\nclass RingGeometry extends Geometry {\n\n\tconstructor( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n}\n\n// RingBufferGeometry\n\nclass RingBufferGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 0.5;\n\t\touterRadius = outerRadius || 1;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\n\nexport { RingGeometry, RingBufferGeometry };\n"],"names":["RingGeometry","Geometry","[object Object]","innerRadius","outerRadius","thetaSegments","phiSegments","thetaStart","thetaLength","super","this","type","parameters","fromBufferGeometry","RingBufferGeometry","mergeVertices","BufferGeometry","undefined","Math","PI","max","indices","vertices","normals","uvs","radius","radiusStep","vertex","Vector3","uv","Vector2","j","i","segment","x","cos","y","sin","push","z","thetaSegmentLevel","a","b","c","d","setIndex","setAttribute","Float32BufferAttribute"],"mappings":"sOAQA,MAAMA,UAAqBC,EAE1BC,YAAaC,EAAaC,EAAaC,EAAeC,EAAaC,EAAYC,GAE9EC,QAEAC,KAAKC,KAAO,eAEZD,KAAKE,WAAa,CACjBT,YAAaA,EACbC,YAAaA,EACbC,cAAeA,EACfC,YAAaA,EACbC,WAAYA,EACZC,YAAaA,GAGdE,KAAKG,mBAAoB,IAAIC,EAAoBX,EAAaC,EAAaC,EAAeC,EAAaC,EAAYC,IACnHE,KAAKK,iBAQP,MAAMD,UAA2BE,EAEhCd,YAAaC,EAAaC,EAAaC,EAAeC,EAAaC,EAAYC,GAE9EC,QAEAC,KAAKC,KAAO,qBAEZD,KAAKE,WAAa,CACjBT,YAAaA,EACbC,YAAaA,EACbC,cAAeA,EACfC,YAAaA,EACbC,WAAYA,EACZC,YAAaA,GAGdL,EAAcA,GAAe,GAC7BC,EAAcA,GAAe,EAE7BG,OAA4BU,IAAfV,EAA2BA,EAAa,EACrDC,OAA8BS,IAAhBT,EAA4BA,EAAwB,EAAVU,KAAKC,GAE7Dd,OAAkCY,IAAlBZ,EAA8Ba,KAAKE,IAAK,EAAGf,GAAkB,EAK7E,MAAMgB,EAAU,GACVC,EAAW,GACXC,EAAU,GACVC,EAAM,GAIZ,IAAIC,EAAStB,EACb,MAAMuB,GAAiBtB,EAAcD,IAZrCG,OAA8BW,IAAhBX,EAA4BY,KAAKE,IAAK,EAAGd,GAAgB,GAajEqB,EAAS,IAAIC,EACbC,EAAK,IAAIC,EAIf,IAAM,IAAIC,EAAI,EAAGA,GAAKzB,EAAayB,IAAO,CAEzC,IAAM,IAAIC,EAAI,EAAGA,GAAK3B,EAAe2B,IAAO,CAI3C,MAAMC,EAAU1B,EAAayB,EAAI3B,EAAgBG,EAIjDmB,EAAOO,EAAIT,EAASP,KAAKiB,IAAKF,GAC9BN,EAAOS,EAAIX,EAASP,KAAKmB,IAAKJ,GAE9BX,EAASgB,KAAMX,EAAOO,EAAGP,EAAOS,EAAGT,EAAOY,GAI1ChB,EAAQe,KAAM,EAAG,EAAG,GAIpBT,EAAGK,GAAMP,EAAOO,EAAI9B,EAAc,GAAM,EACxCyB,EAAGO,GAAMT,EAAOS,EAAIhC,EAAc,GAAM,EAExCoB,EAAIc,KAAMT,EAAGK,EAAGL,EAAGO,GAMpBX,GAAUC,EAMX,IAAM,IAAIK,EAAI,EAAGA,EAAIzB,EAAayB,IAAO,CAExC,MAAMS,EAAoBT,GAAM1B,EAAgB,GAEhD,IAAM,IAAI2B,EAAI,EAAGA,EAAI3B,EAAe2B,IAAO,CAE1C,MAAMC,EAAUD,EAAIQ,EAEdC,EAAIR,EACJS,EAAIT,EAAU5B,EAAgB,EAC9BsC,EAAIV,EAAU5B,EAAgB,EAC9BuC,EAAIX,EAAU,EAIpBZ,EAAQiB,KAAMG,EAAGC,EAAGE,GACpBvB,EAAQiB,KAAMI,EAAGC,EAAGC,IAQtBlC,KAAKmC,SAAUxB,GACfX,KAAKoC,aAAc,WAAY,IAAIC,EAAwBzB,EAAU,IACrEZ,KAAKoC,aAAc,SAAU,IAAIC,EAAwBxB,EAAS,IAClEb,KAAKoC,aAAc,KAAM,IAAIC,EAAwBvB,EAAK"}