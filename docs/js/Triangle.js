import{V as t,a as i}from"./Object3D.js";const s=new t,n=new t,r=new t,o=new t,e=new t,c=new t,a=new t;class h{constructor(i,s){this.origin=void 0!==i?i:new t,this.direction=void 0!==s?s:new t(0,0,-1)}set(t,i){return this.origin.copy(t),this.direction.copy(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(i,s){return void 0===s&&(s=new t),s.copy(this.direction).multiplyScalar(i).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,s)),this}closestPointToPoint(i,s){void 0===s&&(s=new t),s.subVectors(i,this.origin);const n=s.dot(this.direction);return n<0?s.copy(this.origin):s.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const i=s.subVectors(t,this.origin).dot(this.direction);return i<0?this.origin.distanceToSquared(t):(s.copy(this.direction).multiplyScalar(i).add(this.origin),s.distanceToSquared(t))}distanceSqToSegment(t,i,s,e){n.copy(t).add(i).multiplyScalar(.5),r.copy(i).sub(t).normalize(),o.copy(this.origin).sub(n);const c=.5*t.distanceTo(i),a=-this.direction.dot(r),h=o.dot(this.direction),l=-o.dot(r),d=o.lengthSq(),u=Math.abs(1-a*a);let p,y,m,g;if(u>0)if(p=a*l-h,y=a*h-l,g=c*u,p>=0)if(y>=-g)if(y<=g){const t=1/u;p*=t,y*=t,m=p*(p+a*y+2*h)+y*(a*p+y+2*l)+d}else y=c,p=Math.max(0,-(a*y+h)),m=-p*p+y*(y+2*l)+d;else y=-c,p=Math.max(0,-(a*y+h)),m=-p*p+y*(y+2*l)+d;else y<=-g?(p=Math.max(0,-(-a*c+h)),y=p>0?-c:Math.min(Math.max(-c,-l),c),m=-p*p+y*(y+2*l)+d):y<=g?(p=0,y=Math.min(Math.max(-c,-l),c),m=y*(y+2*l)+d):(p=Math.max(0,-(a*c+h)),y=p>0?c:Math.min(Math.max(-c,-l),c),m=-p*p+y*(y+2*l)+d);else y=a>0?-c:c,p=Math.max(0,-(a*y+h)),m=-p*p+y*(y+2*l)+d;return s&&s.copy(this.direction).multiplyScalar(p).add(this.origin),e&&e.copy(r).multiplyScalar(y).add(n),m}intersectSphere(t,i){s.subVectors(t.center,this.origin);const n=s.dot(this.direction),r=s.dot(s)-n*n,o=t.radius*t.radius;if(r>o)return null;const e=Math.sqrt(o-r),c=n-e,a=n+e;return c<0&&a<0?null:c<0?this.at(a,i):this.at(c,i)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const i=t.normal.dot(this.direction);if(0===i)return 0===t.distanceToPoint(this.origin)?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/i;return s>=0?s:null}intersectPlane(t,i){const s=this.distanceToPlane(t);return null===s?null:this.at(s,i)}intersectsPlane(t){const i=t.distanceToPoint(this.origin);if(0===i)return!0;return t.normal.dot(this.direction)*i<0}intersectBox(t,i){let s,n,r,o,e,c;const a=1/this.direction.x,h=1/this.direction.y,l=1/this.direction.z,d=this.origin;return a>=0?(s=(t.min.x-d.x)*a,n=(t.max.x-d.x)*a):(s=(t.max.x-d.x)*a,n=(t.min.x-d.x)*a),h>=0?(r=(t.min.y-d.y)*h,o=(t.max.y-d.y)*h):(r=(t.max.y-d.y)*h,o=(t.min.y-d.y)*h),s>o||r>n?null:((r>s||s!=s)&&(s=r),(o<n||n!=n)&&(n=o),l>=0?(e=(t.min.z-d.z)*l,c=(t.max.z-d.z)*l):(e=(t.max.z-d.z)*l,c=(t.min.z-d.z)*l),s>c||e>n?null:((e>s||s!=s)&&(s=e),(c<n||n!=n)&&(n=c),n<0?null:this.at(s>=0?s:n,i)))}intersectsBox(t){return null!==this.intersectBox(t,s)}intersectTriangle(t,i,s,n,r){e.subVectors(i,t),c.subVectors(s,t),a.crossVectors(e,c);let h,l=this.direction.dot(a);if(l>0){if(n)return null;h=1}else{if(!(l<0))return null;h=-1,l=-l}o.subVectors(this.origin,t);const d=h*this.direction.dot(c.crossVectors(o,c));if(d<0)return null;const u=h*this.direction.dot(e.cross(o));if(u<0)return null;if(d+u>l)return null;const p=-h*o.dot(a);return p<0?null:this.at(p/l,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}const l=new t,d=new t,u=new i;class p{constructor(i,s){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==i?i:new t(1,0,0),this.constant=void 0!==s?s:0}set(t,i){return this.normal.copy(t),this.constant=i,this}setComponents(t,i,s,n){return this.normal.set(t,i,s),this.constant=n,this}setFromNormalAndCoplanarPoint(t,i){return this.normal.copy(t),this.constant=-i.dot(this.normal),this}setFromCoplanarPoints(t,i,s){const n=l.subVectors(s,i).cross(d.subVectors(t,i)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(i,s){return void 0===s&&(s=new t),s.copy(this.normal).multiplyScalar(-this.distanceToPoint(i)).add(i)}intersectLine(i,s){void 0===s&&(s=new t);const n=i.delta(l),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(i.start)?s.copy(i.start):void 0;const o=-(i.start.dot(this.normal)+this.constant)/r;return o<0||o>1?void 0:s.copy(n).multiplyScalar(o).add(i.start)}intersectsLine(t){const i=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return i<0&&s>0||s<0&&i>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(i){return void 0===i&&(i=new t),i.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,i){const s=i||u.getNormalMatrix(t),n=this.coplanarPoint(l).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-n.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const y=new t,m=new t,g=new t,b=new t,w=new t,x=new t,V=new t,P=new t,S=new t,f=new t;class T{constructor(i,s,n){this.a=void 0!==i?i:new t,this.b=void 0!==s?s:new t,this.c=void 0!==n?n:new t}static getNormal(i,s,n,r){void 0===r&&(r=new t),r.subVectors(n,s),y.subVectors(i,s),r.cross(y);const o=r.lengthSq();return o>0?r.multiplyScalar(1/Math.sqrt(o)):r.set(0,0,0)}static getBarycoord(i,s,n,r,o){y.subVectors(r,s),m.subVectors(n,s),g.subVectors(i,s);const e=y.dot(y),c=y.dot(m),a=y.dot(g),h=m.dot(m),l=m.dot(g),d=e*h-c*c;if(void 0===o&&(o=new t),0===d)return o.set(-2,-1,-1);const u=1/d,p=(h*a-c*l)*u,b=(e*l-c*a)*u;return o.set(1-p-b,b,p)}static containsPoint(t,i,s,n){return this.getBarycoord(t,i,s,n,b),b.x>=0&&b.y>=0&&b.x+b.y<=1}static getUV(t,i,s,n,r,o,e,c){return this.getBarycoord(t,i,s,n,b),c.set(0,0),c.addScaledVector(r,b.x),c.addScaledVector(o,b.y),c.addScaledVector(e,b.z),c}static isFrontFacing(t,i,s,n){return y.subVectors(s,i),m.subVectors(t,i),y.cross(m).dot(n)<0}set(t,i,s){return this.a.copy(t),this.b.copy(i),this.c.copy(s),this}setFromPointsAndIndices(t,i,s,n){return this.a.copy(t[i]),this.b.copy(t[s]),this.c.copy(t[n]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return y.subVectors(this.c,this.b),m.subVectors(this.a,this.b),.5*y.cross(m).length()}getMidpoint(i){return void 0===i&&(i=new t),i.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return T.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(t=new p),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,i){return T.getBarycoord(t,this.a,this.b,this.c,i)}getUV(t,i,s,n,r){return T.getUV(t,this.a,this.b,this.c,i,s,n,r)}containsPoint(t){return T.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return T.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(i,s){void 0===s&&(s=new t);const n=this.a,r=this.b,o=this.c;let e,c;w.subVectors(r,n),x.subVectors(o,n),P.subVectors(i,n);const a=w.dot(P),h=x.dot(P);if(a<=0&&h<=0)return s.copy(n);S.subVectors(i,r);const l=w.dot(S),d=x.dot(S);if(l>=0&&d<=l)return s.copy(r);const u=a*d-l*h;if(u<=0&&a>=0&&l<=0)return e=a/(a-l),s.copy(n).addScaledVector(w,e);f.subVectors(i,o);const p=w.dot(f),y=x.dot(f);if(y>=0&&p<=y)return s.copy(o);const m=p*h-a*y;if(m<=0&&h>=0&&y<=0)return c=h/(h-y),s.copy(n).addScaledVector(x,c);const g=l*y-p*d;if(g<=0&&d-l>=0&&p-y>=0)return V.subVectors(o,r),c=(d-l)/(d-l+(p-y)),s.copy(r).addScaledVector(V,c);const b=1/(g+m+u);return e=m*b,c=u*b,s.copy(n).addScaledVector(w,e).addScaledVector(x,c)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}export{p as P,h as R,T};
//# sourceMappingURL=Triangle.js.map
