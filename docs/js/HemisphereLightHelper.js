import{V as t,b as e,C as s,a as o,c as r,M as n,R as i,S as a,d as c,O as l,e as h,D as u,B as p,E as f,f as d,g as m,F as g,h as y}from"./BufferGeometry.js";const v=new t,x=new t,b=new e;class w{constructor(e,s){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==e?e:new t(1,0,0),this.constant=void 0!==s?s:0}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,o){return this.normal.set(t,e,s),this.constant=o,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const o=v.subVectors(s,e).cross(x.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(o,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(e,s){return void 0===s&&(s=new t),s.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,s){void 0===s&&(s=new t);const o=e.delta(v),r=this.normal.dot(o);if(0===r)return 0===this.distanceToPoint(e.start)?s.copy(e.start):void 0;const n=-(e.start.dot(this.normal)+this.constant)/r;return n<0||n>1?void 0:s.copy(o).multiplyScalar(n).add(e.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(e){return void 0===e&&(e=new t),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||b.getNormalMatrix(t),o=this.coplanarPoint(v).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-o.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const N=new t,M=new t,V=new t,B=new t,U=new t,S=new t,A=new t,I=new t,T=new t,P=new t;class z{constructor(e,s,o){this.a=void 0!==e?e:new t,this.b=void 0!==s?s:new t,this.c=void 0!==o?o:new t}static getNormal(e,s,o,r){void 0===r&&(r=new t),r.subVectors(o,s),N.subVectors(e,s),r.cross(N);const n=r.lengthSq();return n>0?r.multiplyScalar(1/Math.sqrt(n)):r.set(0,0,0)}static getBarycoord(e,s,o,r,n){N.subVectors(r,s),M.subVectors(o,s),V.subVectors(e,s);const i=N.dot(N),a=N.dot(M),c=N.dot(V),l=M.dot(M),h=M.dot(V),u=i*l-a*a;if(void 0===n&&(n=new t),0===u)return n.set(-2,-1,-1);const p=1/u,f=(l*c-a*h)*p,d=(i*h-a*c)*p;return n.set(1-f-d,d,f)}static containsPoint(t,e,s,o){return this.getBarycoord(t,e,s,o,B),B.x>=0&&B.y>=0&&B.x+B.y<=1}static getUV(t,e,s,o,r,n,i,a){return this.getBarycoord(t,e,s,o,B),a.set(0,0),a.addScaledVector(r,B.x),a.addScaledVector(n,B.y),a.addScaledVector(i,B.z),a}static isFrontFacing(t,e,s,o){return N.subVectors(s,e),M.subVectors(t,e),N.cross(M).dot(o)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,o){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[o]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return N.subVectors(this.c,this.b),M.subVectors(this.a,this.b),.5*N.cross(M).length()}getMidpoint(e){return void 0===e&&(e=new t),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return z.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(t=new w),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return z.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,s,o,r){return z.getUV(t,this.a,this.b,this.c,e,s,o,r)}containsPoint(t){return z.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return z.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(e,s){void 0===s&&(s=new t);const o=this.a,r=this.b,n=this.c;let i,a;U.subVectors(r,o),S.subVectors(n,o),I.subVectors(e,o);const c=U.dot(I),l=S.dot(I);if(c<=0&&l<=0)return s.copy(o);T.subVectors(e,r);const h=U.dot(T),u=S.dot(T);if(h>=0&&u<=h)return s.copy(r);const p=c*u-h*l;if(p<=0&&c>=0&&h<=0)return i=c/(c-h),s.copy(o).addScaledVector(U,i);P.subVectors(e,n);const f=U.dot(P),d=S.dot(P);if(d>=0&&f<=d)return s.copy(n);const m=f*l-c*d;if(m<=0&&l>=0&&d<=0)return a=l/(l-d),s.copy(o).addScaledVector(S,a);const g=h*d-f*u;if(g<=0&&u-h>=0&&f-d>=0)return A.subVectors(n,r),a=(u-h)/(u-h+(f-d)),s.copy(r).addScaledVector(A,a);const y=1/(g+m+p);return i=m*y,a=p*y,s.copy(o).addScaledVector(U,i).addScaledVector(S,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class F{constructor(e,o,r,n,i,a){this.a=e,this.b=o,this.c=r,this.normal=n&&n.isVector3?n:new t,this.vertexNormals=Array.isArray(n)?n:[],this.color=i&&i.isColor?i:new s,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=void 0!==a?a:0}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,s=t.vertexNormals.length;e<s;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,s=t.vertexColors.length;e<s;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}}function _(t){o.call(this),this.type="MeshBasicMaterial",this.color=new s(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=r,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}_.prototype=Object.create(o.prototype),_.prototype.constructor=_,_.prototype.isMeshBasicMaterial=!0,_.prototype.copy=function(t){return o.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this};const k=new n,C=new i,j=new a,X=new t,D=new t,O=new t,G=new t,L=new t,q=new t,R=new t,W=new t,Y=new t,Z=new c,E=new c,J=new c,H=new t,K=new t;function Q(t,e){l.call(this),this.type="Mesh",this.geometry=void 0!==t?t:new p,this.material=void 0!==e?e:new _,this.updateMorphTargets()}function $(t,e,s,o,r,n,i,a){let c;if(c=e.side===h?o.intersectTriangle(i,n,r,!0,a):o.intersectTriangle(r,n,i,e.side!==u,a),null===c)return null;K.copy(a),K.applyMatrix4(t.matrixWorld);const l=s.ray.origin.distanceTo(K);return l<s.near||l>s.far?null:{distance:l,point:K.clone(),object:t}}function tt(t,e,s,o,r,n,i,a,l,h,u,p){X.fromBufferAttribute(r,h),D.fromBufferAttribute(r,u),O.fromBufferAttribute(r,p);const f=t.morphTargetInfluences;if(e.morphTargets&&n&&f){R.set(0,0,0),W.set(0,0,0),Y.set(0,0,0);for(let t=0,e=n.length;t<e;t++){const e=f[t],s=n[t];0!==e&&(G.fromBufferAttribute(s,h),L.fromBufferAttribute(s,u),q.fromBufferAttribute(s,p),i?(R.addScaledVector(G,e),W.addScaledVector(L,e),Y.addScaledVector(q,e)):(R.addScaledVector(G.sub(X),e),W.addScaledVector(L.sub(D),e),Y.addScaledVector(q.sub(O),e)))}X.add(R),D.add(W),O.add(Y)}t.isSkinnedMesh&&(t.boneTransform(h,X),t.boneTransform(u,D),t.boneTransform(p,O));const d=$(t,e,s,o,X,D,O,H);if(d){a&&(Z.fromBufferAttribute(a,h),E.fromBufferAttribute(a,u),J.fromBufferAttribute(a,p),d.uv=z.getUV(H,X,D,O,Z,E,J,new c)),l&&(Z.fromBufferAttribute(l,h),E.fromBufferAttribute(l,u),J.fromBufferAttribute(l,p),d.uv2=z.getUV(H,X,D,O,Z,E,J,new c));const t=new F(h,u,p);z.getNormal(X,D,O,t.normal),d.face=t}return d}Q.prototype=Object.assign(Object.create(l.prototype),{constructor:Q,isMesh:!0,copy:function(t){return l.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,s=Object.keys(e);if(s.length>0){const t=e[s[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,s=t.length;e<s;e++){const s=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length}},raycast:function(t,e){const s=this.geometry,o=this.material,r=this.matrixWorld;if(void 0===o)return;if(null===s.boundingSphere&&s.computeBoundingSphere(),j.copy(s.boundingSphere),j.applyMatrix4(r),!1===t.ray.intersectsSphere(j))return;if(k.getInverse(r),C.copy(t.ray).applyMatrix4(k),null!==s.boundingBox&&!1===C.intersectsBox(s.boundingBox))return;let n;if(s.isBufferGeometry){const r=s.index,i=s.attributes.position,a=s.morphAttributes.position,c=s.morphTargetsRelative,l=s.attributes.uv,h=s.attributes.uv2,u=s.groups,p=s.drawRange;if(null!==r)if(Array.isArray(o))for(let s=0,f=u.length;s<f;s++){const f=u[s],d=o[f.materialIndex];for(let s=Math.max(f.start,p.start),o=Math.min(f.start+f.count,p.start+p.count);s<o;s+=3){const o=r.getX(s),u=r.getX(s+1),p=r.getX(s+2);n=tt(this,d,t,C,i,a,c,l,h,o,u,p),n&&(n.faceIndex=Math.floor(s/3),n.face.materialIndex=f.materialIndex,e.push(n))}}else{for(let s=Math.max(0,p.start),u=Math.min(r.count,p.start+p.count);s<u;s+=3){const u=r.getX(s),p=r.getX(s+1),f=r.getX(s+2);n=tt(this,o,t,C,i,a,c,l,h,u,p,f),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}else if(void 0!==i)if(Array.isArray(o))for(let s=0,r=u.length;s<r;s++){const r=u[s],f=o[r.materialIndex];for(let s=Math.max(r.start,p.start),o=Math.min(r.start+r.count,p.start+p.count);s<o;s+=3){n=tt(this,f,t,C,i,a,c,l,h,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),n.face.materialIndex=r.materialIndex,e.push(n))}}else{for(let s=Math.max(0,p.start),r=Math.min(i.count,p.start+p.count);s<r;s+=3){n=tt(this,o,t,C,i,a,c,l,h,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}}else if(s.isGeometry){const r=Array.isArray(o),i=s.vertices,a=s.faces;let l;const h=s.faceVertexUvs[0];h.length>0&&(l=h);for(let s=0,h=a.length;s<h;s++){const h=a[s],u=r?o[h.materialIndex]:o;if(void 0===u)continue;const p=i[h.a],f=i[h.b],d=i[h.c];if(n=$(this,u,t,C,p,f,d,H),n){if(l&&l[s]){const t=l[s];Z.copy(t[0]),E.copy(t[1]),J.copy(t[2]),n.uv=z.getUV(H,p,f,d,Z,E,J,new c)}n.face=h,n.faceIndex=s,e.push(n)}}}}});let et=0;const st=new n,ot=new l,rt=new t;function nt(){Object.defineProperty(this,"id",{value:et+=2}),this.uuid=m.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}nt.prototype=Object.assign(Object.create(f.prototype),{constructor:nt,isGeometry:!0,applyMatrix4:function(t){const s=(new e).getNormalMatrix(t);for(let e=0,s=this.vertices.length;e<s;e++){this.vertices[e].applyMatrix4(t)}for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.normal.applyMatrix3(s).normalize();for(let t=0,o=e.vertexNormals.length;t<o;t++)e.vertexNormals[t].applyMatrix3(s).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(t){return st.makeRotationX(t),this.applyMatrix4(st),this},rotateY:function(t){return st.makeRotationY(t),this.applyMatrix4(st),this},rotateZ:function(t){return st.makeRotationZ(t),this.applyMatrix4(st),this},translate:function(t,e,s){return st.makeTranslation(t,e,s),this.applyMatrix4(st),this},scale:function(t,e,s){return st.makeScale(t,e,s),this.applyMatrix4(st),this},lookAt:function(t){return ot.lookAt(t),ot.updateMatrix(),this.applyMatrix4(ot.matrix),this},fromBufferGeometry:function(e){const o=this,r=null!==e.index?e.index:void 0,n=e.attributes;if(void 0===n.position)return this;const i=n.position,a=n.normal,l=n.color,h=n.uv,u=n.uv2;void 0!==u&&(this.faceVertexUvs[1]=[]);for(let e=0;e<i.count;e++)o.vertices.push((new t).fromBufferAttribute(i,e)),void 0!==l&&o.colors.push((new s).fromBufferAttribute(l,e));function p(e,s,r,n){const i=void 0===l?[]:[o.colors[e].clone(),o.colors[s].clone(),o.colors[r].clone()],p=void 0===a?[]:[(new t).fromBufferAttribute(a,e),(new t).fromBufferAttribute(a,s),(new t).fromBufferAttribute(a,r)],f=new F(e,s,r,p,i,n);o.faces.push(f),void 0!==h&&o.faceVertexUvs[0].push([(new c).fromBufferAttribute(h,e),(new c).fromBufferAttribute(h,s),(new c).fromBufferAttribute(h,r)]),void 0!==u&&o.faceVertexUvs[1].push([(new c).fromBufferAttribute(u,e),(new c).fromBufferAttribute(u,s),(new c).fromBufferAttribute(u,r)])}const f=e.groups;if(f.length>0)for(let t=0;t<f.length;t++){const e=f[t],s=e.start;for(let t=s,o=s+e.count;t<o;t+=3)void 0!==r?p(r.getX(t),r.getX(t+1),r.getX(t+2),e.materialIndex):p(t,t+1,t+2,e.materialIndex)}else if(void 0!==r)for(let t=0;t<r.count;t+=3)p(r.getX(t),r.getX(t+1),r.getX(t+2));else for(let t=0;t<i.count;t+=3)p(t,t+1,t+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(rt).negate(),this.translate(rt.x,rt.y,rt.z),this},normalize:function(){this.computeBoundingSphere();const t=this.boundingSphere.center,e=this.boundingSphere.radius,s=0===e?1:1/e,o=new n;return o.set(s,0,0,-s*t.x,0,s,0,-s*t.y,0,0,s,-s*t.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){const e=new t,s=new t;for(let t=0,o=this.faces.length;t<o;t++){const o=this.faces[t],r=this.vertices[o.a],n=this.vertices[o.b],i=this.vertices[o.c];e.subVectors(i,n),s.subVectors(r,n),e.cross(s),e.normalize(),o.normal.copy(e)}},computeVertexNormals:function(e){void 0===e&&(e=!0);const s=new Array(this.vertices.length);for(let e=0,o=this.vertices.length;e<o;e++)s[e]=new t;if(e){const e=new t,o=new t;for(let t=0,r=this.faces.length;t<r;t++){const r=this.faces[t],n=this.vertices[r.a],i=this.vertices[r.b],a=this.vertices[r.c];e.subVectors(a,i),o.subVectors(n,i),e.cross(o),s[r.a].add(e),s[r.b].add(e),s[r.c].add(e)}}else{this.computeFaceNormals();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];s[e.a].add(e.normal),s[e.b].add(e.normal),s[e.c].add(e.normal)}}for(let t=0,e=this.vertices.length;t<e;t++)s[t].normalize();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t],o=e.vertexNormals;3===o.length?(o[0].copy(s[e.a]),o[1].copy(s[e.b]),o[2].copy(s[e.c])):(o[0]=s[e.a].clone(),o[1]=s[e.b].clone(),o[2]=s[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t],s=e.vertexNormals;3===s.length?(s[0].copy(e.normal),s[1].copy(e.normal),s[2].copy(e.normal)):(s[0]=e.normal.clone(),s[1]=e.normal.clone(),s[2]=e.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,s=e.vertexNormals.length;t<s;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new nt;e.faces=this.faces;for(let s=0,o=this.morphTargets.length;s<o;s++){if(!this.morphNormals[s]){this.morphNormals[s]={},this.morphNormals[s].faceNormals=[],this.morphNormals[s].vertexNormals=[];const e=this.morphNormals[s].faceNormals,o=this.morphNormals[s].vertexNormals;for(let s=0,r=this.faces.length;s<r;s++){const s=new t,r={a:new t,b:new t,c:new t};e.push(s),o.push(r)}}const o=this.morphNormals[s];e.vertices=this.morphTargets[s].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t],s=o.faceNormals[t],r=o.vertexNormals[t];s.copy(e.normal),r.a.copy(e.vertexNormals[0]),r.b.copy(e.vertexNormals[1]),r.c.copy(e.vertexNormals[2])}}for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new d),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new a),this.boundingSphere.setFromPoints(this.vertices)},merge:function(t,s,o){if(!t||!t.isGeometry)return;let r;const n=this.vertices.length,i=this.vertices,a=t.vertices,c=this.faces,l=t.faces,h=this.colors,u=t.colors;void 0===o&&(o=0),void 0!==s&&(r=(new e).getNormalMatrix(s));for(let t=0,e=a.length;t<e;t++){const e=a[t].clone();void 0!==s&&e.applyMatrix4(s),i.push(e)}for(let t=0,e=u.length;t<e;t++)h.push(u[t].clone());for(let t=0,e=l.length;t<e;t++){const e=l[t];let s,i;const a=e.vertexNormals,h=e.vertexColors,u=new F(e.a+n,e.b+n,e.c+n);u.normal.copy(e.normal),void 0!==r&&u.normal.applyMatrix3(r).normalize();for(let t=0,e=a.length;t<e;t++)s=a[t].clone(),void 0!==r&&s.applyMatrix3(r).normalize(),u.vertexNormals.push(s);u.color.copy(e.color);for(let t=0,e=h.length;t<e;t++)i=h[t],u.vertexColors.push(i.clone());u.materialIndex=e.materialIndex+o,c.push(u)}for(let e=0,s=t.faceVertexUvs.length;e<s;e++){const s=t.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let t=0,o=s.length;t<o;t++){const o=s[t],r=[];for(let t=0,e=o.length;t<e;t++)r.push(o[t].clone());this.faceVertexUvs[e].push(r)}}},mergeMesh:function(t){t&&t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),this.merge(t.geometry,t.matrix))},mergeVertices:function(){const t={},e=[],s=[],o=Math.pow(10,4);for(let r=0,n=this.vertices.length;r<n;r++){const n=this.vertices[r],i=Math.round(n.x*o)+"_"+Math.round(n.y*o)+"_"+Math.round(n.z*o);void 0===t[i]?(t[i]=r,e.push(this.vertices[r]),s[r]=e.length-1):s[r]=s[t[i]]}const r=[];for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.a=s[e.a],e.b=s[e.b],e.c=s[e.c];const o=[e.a,e.b,e.c];for(let e=0;e<3;e++)if(o[e]===o[(e+1)%3]){r.push(t);break}}for(let t=r.length-1;t>=0;t--){const e=r[t];this.faces.splice(e,1);for(let t=0,s=this.faceVertexUvs.length;t<s;t++)this.faceVertexUvs[t].splice(e,1)}const n=this.vertices.length-e.length;return this.vertices=e,n},setFromPoints:function(e){this.vertices=[];for(let s=0,o=e.length;s<o;s++){const o=e[s];this.vertices.push(new t(o.x,o.y,o.z||0))}return this},sortFacesByMaterialIndex:function(){const t=this.faces,e=t.length;for(let s=0;s<e;s++)t[s]._id=s;t.sort((function(t,e){return t.materialIndex-e.materialIndex}));const s=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let r,n;s&&s.length===e&&(r=[]),o&&o.length===e&&(n=[]);for(let i=0;i<e;i++){const e=t[i]._id;r&&r.push(s[e]),n&&n.push(o[e])}r&&(this.faceVertexUvs[0]=r),n&&(this.faceVertexUvs[1]=n)},toJSON:function(){const t={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),void 0!==this.parameters){const e=this.parameters;for(const s in e)void 0!==e[s]&&(t[s]=e[s]);return t}const e=[];for(let t=0;t<this.vertices.length;t++){const s=this.vertices[t];e.push(s.x,s.y,s.z)}const s=[],o=[],r={},n=[],i={},a=[],c={};for(let t=0;t<this.faces.length;t++){const e=this.faces[t],o=!0,r=!1,n=void 0!==this.faceVertexUvs[0][t],i=e.normal.length()>0,a=e.vertexNormals.length>0,c=1!==e.color.r||1!==e.color.g||1!==e.color.b,f=e.vertexColors.length>0;let d=0;if(d=l(d,0,0),d=l(d,1,o),d=l(d,2,r),d=l(d,3,n),d=l(d,4,i),d=l(d,5,a),d=l(d,6,c),d=l(d,7,f),s.push(d),s.push(e.a,e.b,e.c),s.push(e.materialIndex),n){const e=this.faceVertexUvs[0][t];s.push(p(e[0]),p(e[1]),p(e[2]))}if(i&&s.push(h(e.normal)),a){const t=e.vertexNormals;s.push(h(t[0]),h(t[1]),h(t[2]))}if(c&&s.push(u(e.color)),f){const t=e.vertexColors;s.push(u(t[0]),u(t[1]),u(t[2]))}}function l(t,e,s){return s?t|1<<e:t&~(1<<e)}function h(t){const e=t.x.toString()+t.y.toString()+t.z.toString();return void 0!==r[e]||(r[e]=o.length/3,o.push(t.x,t.y,t.z)),r[e]}function u(t){const e=t.r.toString()+t.g.toString()+t.b.toString();return void 0!==i[e]||(i[e]=n.length,n.push(t.getHex())),i[e]}function p(t){const e=t.x.toString()+t.y.toString();return void 0!==c[e]||(c[e]=a.length/2,a.push(t.x,t.y)),c[e]}return t.data={},t.data.vertices=e,t.data.normals=o,n.length>0&&(t.data.colors=n),a.length>0&&(t.data.uvs=[a]),t.data.faces=s,t},clone:function(){return(new nt).copy(this)},copy:function(t){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;const e=t.vertices;for(let t=0,s=e.length;t<s;t++)this.vertices.push(e[t].clone());const s=t.colors;for(let t=0,e=s.length;t<e;t++)this.colors.push(s[t].clone());const o=t.faces;for(let t=0,e=o.length;t<e;t++)this.faces.push(o[t].clone());for(let e=0,s=t.faceVertexUvs.length;e<s;e++){const s=t.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let t=0,o=s.length;t<o;t++){const o=s[t],r=[];for(let t=0,e=o.length;t<e;t++){const e=o[t];r.push(e.clone())}this.faceVertexUvs[e].push(r)}}const r=t.morphTargets;for(let t=0,e=r.length;t<e;t++){const e={};if(e.name=r[t].name,void 0!==r[t].vertices){e.vertices=[];for(let s=0,o=r[t].vertices.length;s<o;s++)e.vertices.push(r[t].vertices[s].clone())}if(void 0!==r[t].normals){e.normals=[];for(let s=0,o=r[t].normals.length;s<o;s++)e.normals.push(r[t].normals[s].clone())}this.morphTargets.push(e)}const n=t.morphNormals;for(let t=0,e=n.length;t<e;t++){const e={};if(void 0!==n[t].vertexNormals){e.vertexNormals=[];for(let s=0,o=n[t].vertexNormals.length;s<o;s++){const o=n[t].vertexNormals[s],r={};r.a=o.a.clone(),r.b=o.b.clone(),r.c=o.c.clone(),e.vertexNormals.push(r)}}if(void 0!==n[t].faceNormals){e.faceNormals=[];for(let s=0,o=n[t].faceNormals.length;s<o;s++)e.faceNormals.push(n[t].faceNormals[s].clone())}this.morphNormals.push(e)}const i=t.skinWeights;for(let t=0,e=i.length;t<e;t++)this.skinWeights.push(i[t].clone());const a=t.skinIndices;for(let t=0,e=a.length;t<e;t++)this.skinIndices.push(a[t].clone());const c=t.lineDistances;for(let t=0,e=c.length;t<e;t++)this.lineDistances.push(c[t]);const l=t.boundingBox;null!==l&&(this.boundingBox=l.clone());const h=t.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=t.elementsNeedUpdate,this.verticesNeedUpdate=t.verticesNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.lineDistancesNeedUpdate=t.lineDistancesNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class it extends p{constructor(e,s,o,r){super(),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:s,radius:o,detail:r},o=o||1;const n=[],i=[];function a(t,e,s,o){const r=Math.pow(2,o),n=[];for(let o=0;o<=r;o++){n[o]=[];const i=t.clone().lerp(s,o/r),a=e.clone().lerp(s,o/r),c=r-o;for(let t=0;t<=c;t++)n[o][t]=0===t&&o===r?i:i.clone().lerp(a,t/c)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const s=Math.floor(e/2);e%2==0?(l(n[t][s+1]),l(n[t+1][s]),l(n[t][s])):(l(n[t][s+1]),l(n[t+1][s+1]),l(n[t+1][s]))}}function l(t){n.push(t.x,t.y,t.z)}function h(t,s){const o=3*t;s.x=e[o+0],s.y=e[o+1],s.z=e[o+2]}function u(t,e,s,o){o<0&&1===t.x&&(i[e]=t.x-1),0===s.x&&0===s.z&&(i[e]=o/2/Math.PI+.5)}function p(t){return Math.atan2(t.z,-t.x)}!function(e){const o=new t,r=new t,n=new t;for(let t=0;t<s.length;t+=3)h(s[t+0],o),h(s[t+1],r),h(s[t+2],n),a(o,r,n,e)}(r=r||0),function(e){const s=new t;for(let t=0;t<n.length;t+=3)s.x=n[t+0],s.y=n[t+1],s.z=n[t+2],s.normalize().multiplyScalar(e),n[t+0]=s.x,n[t+1]=s.y,n[t+2]=s.z}(o),function(){const e=new t;for(let t=0;t<n.length;t+=3){e.x=n[t+0],e.y=n[t+1],e.z=n[t+2];const o=p(e)/2/Math.PI+.5,r=(s=e,Math.atan2(-s.y,Math.sqrt(s.x*s.x+s.z*s.z))/Math.PI+.5);i.push(o,1-r)}var s;(function(){const e=new t,s=new t,o=new t,r=new t,a=new c,l=new c,h=new c;for(let t=0,c=0;t<n.length;t+=9,c+=6){e.set(n[t+0],n[t+1],n[t+2]),s.set(n[t+3],n[t+4],n[t+5]),o.set(n[t+6],n[t+7],n[t+8]),a.set(i[c+0],i[c+1]),l.set(i[c+2],i[c+3]),h.set(i[c+4],i[c+5]),r.copy(e).add(s).add(o).divideScalar(3);const f=p(r);u(a,c+0,e,f),u(l,c+2,s,f),u(h,c+4,o,f)}})(),function(){for(let t=0;t<i.length;t+=6){const e=i[t+0],s=i[t+2],o=i[t+4],r=Math.max(e,s,o),n=Math.min(e,s,o);r>.9&&n<.1&&(e<.2&&(i[t+0]+=1),s<.2&&(i[t+2]+=1),o<.2&&(i[t+4]+=1))}}()}(),this.setAttribute("position",new g(n,3)),this.setAttribute("normal",new g(n.slice(),3)),this.setAttribute("uv",new g(i,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}}class at extends it{constructor(t,e){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronBufferGeometry",this.parameters={radius:t,detail:e}}}const ct=new t,lt=new s,ht=new s;class ut extends l{constructor(t,e,s){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=s;const o=new at(e);o.rotateY(.5*Math.PI),this.material=new _({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=o.getAttribute("position"),n=new Float32Array(3*r.count);o.setAttribute("color",new y(n,3)),this.add(new Q(o,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");lt.copy(this.light.color),ht.copy(this.light.groundColor);for(let t=0,s=e.count;t<s;t++){const o=t<s/2?lt:ht;e.setXYZ(t,o.r,o.g,o.b)}e.needsUpdate=!0}t.lookAt(ct.setFromMatrixPosition(this.light.matrixWorld).negate())}}export{ut as HemisphereLightHelper};
