import"./MathUtils.js";import{B as t,D as e}from"./constants.js";import"./Material.js";import"./Color.js";import{MeshBasicMaterial as r}from"./MeshBasicMaterial.js";import"./Quaternion.js";import{M as o,V as n,O as a}from"./Object3D.js";import{S as i,V as s,B as f}from"./BufferGeometry.js";import{R as c,T as u}from"./Triangle.js";import{F as l}from"./Face3.js";const m=new o,h=new c,p=new i,d=new n,g=new n,y=new n,b=new n,x=new n,M=new n,w=new n,T=new n,B=new n,A=new s,I=new s,v=new s,j=new n,S=new n;function V(t,e){a.call(this),this.type="Mesh",this.geometry=void 0!==t?t:new f,this.material=void 0!==e?e:new r,this.updateMorphTargets()}function D(r,o,n,a,i,s,f,c){let u;if(u=o.side===t?a.intersectTriangle(f,s,i,!0,c):a.intersectTriangle(i,s,f,o.side!==e,c),null===u)return null;S.copy(c),S.applyMatrix4(r.matrixWorld);const l=n.ray.origin.distanceTo(S);return l<n.near||l>n.far?null:{distance:l,point:S.clone(),object:r}}function O(t,e,r,o,n,a,i,f,c,m,h,p){d.fromBufferAttribute(n,m),g.fromBufferAttribute(n,h),y.fromBufferAttribute(n,p);const S=t.morphTargetInfluences;if(e.morphTargets&&a&&S){w.set(0,0,0),T.set(0,0,0),B.set(0,0,0);for(let t=0,e=a.length;t<e;t++){const e=S[t],r=a[t];0!==e&&(b.fromBufferAttribute(r,m),x.fromBufferAttribute(r,h),M.fromBufferAttribute(r,p),i?(w.addScaledVector(b,e),T.addScaledVector(x,e),B.addScaledVector(M,e)):(w.addScaledVector(b.sub(d),e),T.addScaledVector(x.sub(g),e),B.addScaledVector(M.sub(y),e)))}d.add(w),g.add(T),y.add(B)}t.isSkinnedMesh&&(t.boneTransform(m,d),t.boneTransform(h,g),t.boneTransform(p,y));const V=D(t,e,r,o,d,g,y,j);if(V){f&&(A.fromBufferAttribute(f,m),I.fromBufferAttribute(f,h),v.fromBufferAttribute(f,p),V.uv=u.getUV(j,d,g,y,A,I,v,new s)),c&&(A.fromBufferAttribute(c,m),I.fromBufferAttribute(c,h),v.fromBufferAttribute(c,p),V.uv2=u.getUV(j,d,g,y,A,I,v,new s));const t=new l(m,h,p);u.getNormal(d,g,y,t.normal),V.face=t}return V}V.prototype=Object.assign(Object.create(a.prototype),{constructor:V,isMesh:!0,copy:function(t){return a.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,r=Object.keys(e);if(r.length>0){const t=e[r[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,r=t.length;e<r;e++){const r=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length}},raycast:function(t,e){const r=this.geometry,o=this.material,n=this.matrixWorld;if(void 0===o)return;if(null===r.boundingSphere&&r.computeBoundingSphere(),p.copy(r.boundingSphere),p.applyMatrix4(n),!1===t.ray.intersectsSphere(p))return;if(m.getInverse(n),h.copy(t.ray).applyMatrix4(m),null!==r.boundingBox&&!1===h.intersectsBox(r.boundingBox))return;let a;if(r.isBufferGeometry){const n=r.index,i=r.attributes.position,s=r.morphAttributes.position,f=r.morphTargetsRelative,c=r.attributes.uv,u=r.attributes.uv2,l=r.groups,m=r.drawRange;if(null!==n)if(Array.isArray(o))for(let r=0,p=l.length;r<p;r++){const p=l[r],d=o[p.materialIndex];for(let r=Math.max(p.start,m.start),o=Math.min(p.start+p.count,m.start+m.count);r<o;r+=3){const o=n.getX(r),l=n.getX(r+1),m=n.getX(r+2);a=O(this,d,t,h,i,s,f,c,u,o,l,m),a&&(a.faceIndex=Math.floor(r/3),a.face.materialIndex=p.materialIndex,e.push(a))}}else{for(let r=Math.max(0,m.start),l=Math.min(n.count,m.start+m.count);r<l;r+=3){const l=n.getX(r),m=n.getX(r+1),p=n.getX(r+2);a=O(this,o,t,h,i,s,f,c,u,l,m,p),a&&(a.faceIndex=Math.floor(r/3),e.push(a))}}else if(void 0!==i)if(Array.isArray(o))for(let r=0,n=l.length;r<n;r++){const n=l[r],p=o[n.materialIndex];for(let r=Math.max(n.start,m.start),o=Math.min(n.start+n.count,m.start+m.count);r<o;r+=3){a=O(this,p,t,h,i,s,f,c,u,r,r+1,r+2),a&&(a.faceIndex=Math.floor(r/3),a.face.materialIndex=n.materialIndex,e.push(a))}}else{for(let r=Math.max(0,m.start),n=Math.min(i.count,m.start+m.count);r<n;r+=3){a=O(this,o,t,h,i,s,f,c,u,r,r+1,r+2),a&&(a.faceIndex=Math.floor(r/3),e.push(a))}}}else if(r.isGeometry){const n=Array.isArray(o),i=r.vertices,f=r.faces;let c;const l=r.faceVertexUvs[0];l.length>0&&(c=l);for(let r=0,l=f.length;r<l;r++){const l=f[r],m=n?o[l.materialIndex]:o;if(void 0===m)continue;const p=i[l.a],d=i[l.b],g=i[l.c];if(a=D(this,m,t,h,p,d,g,j),a){if(c&&c[r]){const t=c[r];A.copy(t[0]),I.copy(t[1]),v.copy(t[2]),a.uv=u.getUV(j,p,d,g,A,I,v,new s)}a.face=l,a.faceIndex=r,e.push(a)}}}}});export{V as Mesh};
