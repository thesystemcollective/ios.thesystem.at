{"version":3,"file":"AnimationMixer.js","sources":["../../node_modules/three/src/animation/AnimationAction.js","../../node_modules/three/src/animation/PropertyMixer.js","../../node_modules/three/src/animation/AnimationMixer.js"],"sourcesContent":["import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat, NormalAnimationBlendMode, AdditiveAnimationBlendMode } from '../constants.js';\n\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot, blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\t\tthis.blendMode = blendMode || clip.blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { AnimationAction };\n","import { Quaternion } from '../math/Quaternion.js';\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tlet mixFunction,\n\t\tmixFunctionAdditive,\n\t\tsetIdentity;\n\n\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\t//\n\t// 'add' is used for additive cumulative results\n\t//\n\t// 'work' is optional and is only present for quaternion types. It is used\n\t// to store intermediate quaternion multiplication results\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\tthis._workIndex = 5;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tmixFunction = this._select;\n\n\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t// additive is not relevant for non-numeric types\n\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t}\n\n\tthis._mixBufferRegion = mixFunction;\n\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\tthis._setIdentity = setIdentity;\n\tthis._origIndex = 3;\n\tthis._addIndex = 4;\n\n\tthis.cumulativeWeight = 0;\n\tthis.cumulativeWeightAdditive = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive: function ( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\t_setAdditiveIdentityNumeric: function () {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t},\n\n\t_setAdditiveIdentityQuaternion: function () {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t},\n\n\t_setAdditiveIdentityOther: function () {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t},\n\n\t_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { PropertyMixer };\n","import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime: function ( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationMixer };\n"],"names":["AnimationAction","[object Object]","mixer","clip","localRoot","blendMode","this","_mixer","_clip","_localRoot","tracks","nTracks","length","interpolants","Array","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","i","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","Infinity","paused","enabled","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","_activateAction","_deactivateAction","reset","stopFading","stopWarping","_isActiveAction","mode","duration","_scheduleFading","fadeOutAction","warp","fadeOut","fadeIn","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","fadeInAction","crossFadeFrom","weightInterpolant","_takeBackControlInterpolant","action","startTimeScale","endTimeScale","now","_lendControlInterpolant","times","parameterPositions","values","sampleValues","timeScaleInterpolant","_root","deltaTime","timeDirection","accuIndex","_updateWeight","startTime","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","AdditiveAnimationBlendMode","j","m","evaluate","accumulateAdditive","NormalAnimationBlendMode","accumulate","interpolantValue","loopCount","pingPong","LoopPingPong","LoopOnce","_setEndings","handle_stop","dispatchEvent","type","direction","loopDelta","Math","floor","abs","pending","atStart","atEnd","ZeroSlopeEnding","WrapAroundEnding","weightNow","weightThen","PropertyMixer","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","AnimationMixer","root","_initMemoryManager","_accuIndex","Object","assign","prototype","stride","offset","currentWeight","mix","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","Quaternion","slerpFlat","workOffset","multiplyQuaternionsFlat","s","create","EventDispatcher","constructor","_bindAction","prototypeAction","bindings","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","track","trackName","name","_addInactiveBinding","path","parsedPath","PropertyBinding","ValueTypeName","getValueSize","resultBuffer","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","keys","firstInactiveBinding","lastActiveBinding","LinearInterpolant","Float32Array","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","AnimationClip","findByName","existingAction","newAction","stopAllAction","stop","update","nActions","sign","_update","nBindings","setTime","timeInSeconds","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"mappings":"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"}