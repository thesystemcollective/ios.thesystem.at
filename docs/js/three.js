import{p as e,g as t,s as i}from"../main.js";import{RingBufferGeometry as r,MeshBasicMaterial as n,Mesh as o,AnimationMixer as l}from"./three.module.js";import{G as c}from"./GLTFLoader.js";export{a as addSkybox,s as spawnModel}from"./GLTFLoader.js";const d=({camera:e,renderer:t})=>()=>{const{innerWidth:s,innerHeight:a}=W;e.aspect=s/a,e.updateProjectionMatrix(),t.setSize(s,a)};let m=null,u=!1;const f=e=>async(t,s)=>{const{camera:a,clock:i,mixer:r,reflect:n,renderer:o,reticle:l,scene:c}=e;if(s){const e=o.xr.getSession();if(!1===u){const t=await e.requestReferenceSpace("viewer"),s=await e.requestHitTestSource({space:t});m=s,e.addEventListener("end",(()=>{u=!1,m=null})),u=!0}if(m){const e=o.xr.getReferenceSpace(),t=s.getHitTestResults(m);if(t.length){if(l){const s=t[0];l.visible=!0,l.matrix.fromArray(s.getPose(e).transform.matrix)}}else l&&(l.visible=!1)}}n.target&&n.camera&&n.skybox&&(W.XR&&(n.skybox.visible=!0),n.target.visible=!1,n.camera.updateCubeMap(o,c),W.XR&&(n.skybox.visible=!1),n.target.visible=!0),r&&r.update(i.getDelta()),o.render(c,a)},p=async()=>{const e=new r(.15,.2,32).rotateX(-M.PI/2),t=new n,s=new o(e,t);return s.matrixAutoUpdate=!1,s.visible=!1,s},b=async(s,a)=>{if(!s)throw new Error("loadModel needs { file } argument to be set.");a.show(e);const i=await((e,s,a)=>new Promise(((i,r)=>{const n=`${t}/${s}`,o=(e=>t=>{if(t.total>0){const s=M.ceil(t.loaded/t.total*100);e.setContent(`${s}% ${t.loaded}/${t.total}`)}t.loaded>=t.total&&e.hide()})(a);e.load(n,i,o,r)})))(new c,s,a),r=i.scene;let n=null;return i.animations&&i.animations.length&&(n=new l(r),i.animations.forEach((e=>n.clipAction(e).play()))),{model:r,mixer:n}},x=e=>{const t=$("#three-gui"),s=$("#exit-button");return t.classList.add("visible"),e={...e,gui:t,exitButton:s},s.addEventListener("click",(()=>{t.classList.remove("visible"),i.end(e)})),t};export{b as loadModel,p as loadReticle,d as onWindowResize,f as render,x as showHUD};
